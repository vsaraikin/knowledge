# Golang Interview Guideline

  * [Типы данных](#%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
    + [Базовые](#%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5)
    + [Что такое iota?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-iota)
    + [Composite Data Types](#composite-data-types)
    + [Что такое слайс и чем он отличается от массива?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%81%D0%BB%D0%B0%D0%B9%D1%81-%D0%B8-%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%BE%D1%82-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0)
      - [Как работает базовая функция append для go?](#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-append-%D0%B4%D0%BB%D1%8F-go)
      - [Какой размер массива выделяется под слайс при его расширении за рамки его емкости?](#%D0%BA%D0%B0%D0%BA%D0%BE%D0%B9-%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0-%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F-%D0%BF%D0%BE%D0%B4-%D1%81%D0%BB%D0%B0%D0%B9%D1%81-%D0%BF%D1%80%D0%B8-%D0%B5%D0%B3%D0%BE-%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%B8%D0%B8-%D0%B7%D0%B0-%D1%80%D0%B0%D0%BC%D0%BA%D0%B8-%D0%B5%D0%B3%D0%BE-%D0%B5%D0%BC%D0%BA%D0%BE%D1%81%D1%82%D0%B8)
      - [Как слайс передается в функцию: по ссылке или значению?](#%D0%BA%D0%B0%D0%BA-%D1%81%D0%BB%D0%B0%D0%B9%D1%81-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%B2-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8E-%D0%BF%D0%BE-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B5-%D0%B8%D0%BB%D0%B8-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8E)
    + [Map в Golang](#map-%D0%B2-golang)
      - [Коллизия в мапе](#%D0%BA%D0%BE%D0%BB%D0%BB%D0%B8%D0%B7%D0%B8%D1%8F-%D0%B2-%D0%BC%D0%B0%D0%BF%D0%B5)
      - [Что может быть ключём map?](#%D1%87%D1%82%D0%BE-%D0%BC%D0%BE%D0%B6%D0%B5%D1%82-%D0%B1%D1%8B%D1%82%D1%8C-%D0%BA%D0%BB%D1%8E%D1%87%D1%91%D0%BC-map)
      - [Что будет в map, если не делать присвоение?](#%D1%87%D1%82%D0%BE-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D0%B2-map-%D0%B5%D1%81%D0%BB%D0%B8-%D0%BD%D0%B5-%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5)
      - [Что такое Sync.map?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-syncmap)
      - [Потокобезопасна ли map?](#%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%B0-%D0%BB%D0%B8-map)
      - [Как словить race condition?](#%D0%BA%D0%B0%D0%BA-%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%82%D1%8C-race-condition)
      - [Почему нельзя брать ссылку на значение, хранящееся по ключу в map?](#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BD%D0%B5%D0%BB%D1%8C%D0%B7%D1%8F-%D0%B1%D1%80%D0%B0%D1%82%D1%8C-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D1%83-%D0%BD%D0%B0-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%85%D1%80%D0%B0%D0%BD%D1%8F%D1%89%D0%B5%D0%B5%D1%81%D1%8F-%D0%BF%D0%BE-%D0%BA%D0%BB%D1%8E%D1%87%D1%83-%D0%B2-map)
      - [Почему не гарантирован порядок обхода?](#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BD%D0%B5-%D0%B3%D0%B0%D1%80%D0%B0%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD-%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B0)
      - [Что такое эвакуация, и в каком случае она будет происходить?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%8D%D0%B2%D0%B0%D0%BA%D1%83%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8-%D0%B2-%D0%BA%D0%B0%D0%BA%D0%BE%D0%BC-%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B5-%D0%BE%D0%BD%D0%B0-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82%D1%8C)
      - [Какие есть особенности синтаксиса получения и записи значений в map?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B5%D1%81%D1%82%D1%8C-%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81%D0%B0-%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B8-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B2-map)
      - [Как происходит поиск по ключу в map?](#%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA-%D0%BF%D0%BE-%D0%BA%D0%BB%D1%8E%D1%87%D1%83-%D0%B2-map)
    + [Как реализовано ООП в go?](#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BE-%D0%BE%D0%BE%D0%BF-%D0%B2-go)
      - [Наследование](#%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
      - [Инкапсуляция](#%D0%B8%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F)
      - [**Полиморфизм**](#%D0%BF%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC)
    + [Операторы в Go](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B2-go)
      - [Можно ли выполнить несколько условий в одном объявленном операторе *switch case*?](#%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BB%D0%B8-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D1%8C-%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B9-%D0%B2-%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC-%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%BC-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B5-switch-case)
  * [Интерфейсы в Golang](#%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B-%D0%B2-golang)
    + [Что такое интерфейсы в go?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B-%D0%B2-go)
    + [Что такое пустой интерфейс?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%83%D1%81%D1%82%D0%BE%D0%B9-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)
    + [Что такое nil интерфейс?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-nil-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)
    + [Как преобразовать интерфейс к другому типу?](#%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81-%D0%BA-%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%BC%D1%83-%D1%82%D0%B8%D0%BF%D1%83)
    + [Как определить тип интерфейса?](#%D0%BA%D0%B0%D0%BA-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B8%D1%82%D1%8C-%D1%82%D0%B8%D0%BF-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B0)
  * [Инструкция defer](#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F-defer)
    + [Зачем используется ключевое слово defer в go?](#%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F-%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-defer-%D0%B2-go)
    + [Как передаются значения в функции, перед которыми указано ключевое слово defer?](#%D0%BA%D0%B0%D0%BA-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%8E%D1%82%D1%81%D1%8F-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B2-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%BC%D0%B8-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D0%BD%D0%BE-%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-defer)
  * [Конкуретность](#%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
    + [Горутины](#%D0%B3%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B)
      - [Преимущества горутин:](#%D0%BF%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0-%D0%B3%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD)
      - [Что происходит при написании go?](#%D1%87%D1%82%D0%BE-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D0%BF%D1%80%D0%B8-%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B8-go)
      - [Как завершить много горутин?](#%D0%BA%D0%B0%D0%BA-%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D1%82%D1%8C-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B3%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD)
      - [Горутины и потоки разница](#%D0%B3%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B-%D0%B8-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0)
    + [Scheduler](#scheduler)
      - [Как работает планировщик?](#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%BF%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA)
      - [Многозадачность в Golang](#%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%B2-golang)
      - [Состояния Горутин](#%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F-%D0%B3%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD)
      - [Ограничения планировщика](#%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA%D0%B0)
    + [Каналы](#%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB%D1%8B)
      - [Буферизированный канал](#%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB)
    + [WaitGroups](#waitgroups)
    + [Graceful shutdown](#graceful-shutdown)
  * [Другие](#%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5)
    + [Что такое захват переменной?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B7%D0%B0%D1%85%D0%B2%D0%B0%D1%82-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9)
    + [Где используется контекст?](#%D0%B3%D0%B4%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82)
    + [Generics](#generics)
    + [Объявление переменных – разница](#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%E2%80%93-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0)
      - [Map](#map)
      - [Slice](#slice)
    + [Мьютексы](#%D0%BC%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81%D1%8B)
    + [Тестирование](#%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
    + [Protobuf](#protobuf)
    + [gRPC](#grpc)
## Типы данных
### Базовые

- Integers ( Signed and Unsigned):
- Floating
- Complex
- Byte
- Rune
- String
- Boolean

> _Чем отличается int от uint?_

`int` содержит диапазон от отрицательных значений до положительных, тогда как `uint` - это диапазон от 0 в строну увеличения положительных значений.

> _Какой результат получим если разделить int на 0 и float на 0?_

Это вопрос с подвохом. Деление `int` на 0 в go невозможно и вызовет ошибку компилятора. Тогда как деление `float` на 0 дает в своем результате бесконечность.

### Что такое iota?

Это идентификатор, который позволяет создавать последовательные не типизированные целочисленные константы.

```go
const (
	C1 = iota + 1
	C2
	C3
)
fmt.Println(C1, C2, C3) // "1 2 3"
```

### Composite Data Types

- Non-Reference Types: Arrays, Structs
- Reference Types: Slices, Maps
- Interface

### Что такое слайс и чем он отличается от массива?

**Slice** – это структура go, которая включает в себя ссылку на базовый массив, а также две переменные **`len(length)`** и **`cap(capacity)`**.

**`len`** это длина слайса - то количество элементов, которое в нём сейчас находится.
**`cap`** - это ёмкость слайса - то количество элементов, которые мы можем записать в слайс сверх **`len`** без его дальнейшего расширения.

**Array** - это последовательно выделенная область памяти. Частью типа array является его размер, который в том числе является не изменяемым.

#### Как работает базовая функция append для go?

Функция принимает на вход слайс и переменное количество элементов для добавления в слайс. **Append** расширяет слайс за пределы его **len**, возвращая при этом новый слайс.

Если количество элементов, которые мы добавляем в слайс, не будет превышать cap, вернется новый слайс, который ссылается на тот же базовый массив, что и предыдущий слайс. 

Если количество добавляемых элементов превысит cap, то вернется новый слайс, базовым для которого будет новый массив.

То есть, длина и вместимость передаются по значению, но массив значений передается по ссылке. Вследствие этого получается неявное поведение: добавленные элементы не сохранятся в исходный слайс, но изменение существующих останется:

```go
func append(slice []Type, elems ...Type) []Type
```

#### Какой размер массива выделяется под слайс при его расширении за рамки его емкости?

Если отвечать на вопрос поверхностно, то можно сказать, что базовый массив расширяется в два раза от нашей capacity.

Отвечая более емко, следует учесть, что при больших значениях расширение будет не в два раза и будет вычисляться по специальной формуле.

Если развернуть ответ полностью, то это будет звучать примерно так: 
- если требуемая `cap` больше чем вдвое исходной `cap`, то новая `cap` будет равна требуемой;
- если это условие не выполнено, а также `len` текущего слайса меньше `1024`, то новая `cap` будет в два раза больше базовой `cap`;
- если первое и второе условия не выполнены, то емкость будет увеличиваться в цикле на четверть от базовой емкости пока не будет обработано переполнение. Посмотреть эти условия более подробно можно в исходниках go.

#### Как слайс передается в функцию: по ссылке или значению?

В Go слайсы на самом деле передаются не по ссылке – они передаются по значению. Однако в этом есть один тонкий нюанс.

Когда вы передаете фрагмент функции, создается копия заголовка фрагмента и передается функции по значению. Этот заголовок содержит указатель на базовый массив, длину фрагмента и емкость фрагмента. Поскольку заголовок слайса представляет собой небольшую структуру, эффективно передавать его по значению.

В то время как заголовок среза передается по значению, базовый массив не копируется. Это означает, что любые изменения, внесенные в элементы среза внутри функции, будут видны вне функции, поскольку они по-прежнему ссылаются на один и тот же базовый массив.
### Map в Golang

Сама  `map`  в go - это структура, реализующая операции хеширования. При этом, так же как и любую структуру, содержащую ссылки на области памяти, `map`  **необходимо инициализировать**. 

`map` ссылается на такие элементы как `bucket`. Каждый `bucket` содержит в себе:

- 8 экстра бит, с помощью которых осуществляется доступ до значений в этом `bucket`;
- ссылку на следующий коллизионный `bucket`;
- 8 пар ключ-значение, уложенных в массив.

>Бакет увеличивается, когда заполняется на 6.5 элементами.

[Как на самом деле устроен тип Map в Golang? | Golang под капотом - YouTube](https://www.youtube.com/watch?v=P_SXTUiA-9Y&t=178s)
#### Коллизия в мапе

Так как хэш-функция не идеальна, передав в нее два разных значения мы можем получить один и тот же результат. В случае с бакетами нам нужно два разных значения положить в один и тот же бакет. Это называется коллизией. Для реализации hashmap необходимо иметь алгоритм их разрешения. 

В golang используется separate chain.

При коллизии (когда сложили в один бакет), то обходим бакет в поисках ключа.

#### Что может быть ключём map?

int, float64, rune, string, **comparable array and structure**, pointer, etc.

Структура может быть ключём до тех пор пока не в полях не будет мапы/слайса.

#### Что будет в map, если не делать присвоение?

Будет паника.

#### Что такое Sync.map?

Предоставляет атомарный доступ.

#### Потокобезопасна ли map?

Нет. Для этого нужно:
1. Заворачиваем в мьютекс.
2. Sync.Map

#### Как словить race condition?

Есть флаг race condition.
`$ go run -race mysrc.go

#### Почему нельзя брать ссылку на значение, хранящееся по ключу в map?

`map` поддерживает процедуру эвакуации. Значения, хранящиеся в определённой ячейки памяти в текущий момент времени, в следующий момент времени уже могут там не храниться.

#### Почему не гарантирован порядок обхода?

#### Что такое эвакуация, и в каком случае она будет происходить?

Эвакуация - это процесс когда `map` переносит свои значения из одной области памяти в другую. Это происходит из-за того что число значений в каждом отдельном `bucket` максимально равно 8.

В тот момент времени, когда среднее количество значений в `bucket` составляет 6.5, go понимает, что размер `map` не удовлетворяет необходимому. Начинается процесс расширения `map`.

Следует отметить, что сам процесс эвакуации может происходить некоторое время, на протяжение которого новые и старые данные будут связаны.

#### Какие есть особенности синтаксиса получения и записи значений в map?

Получить значение из `map`, которую мы предварительно не аллоцировали нельзя, приложение упадет в панику.

Если ключ не найден в `map` в ответ мы получим дефолтное значение для типа значений `map`. То есть, для строки - это будет пустая строка, для int - 0 и так далее. Для того, чтобы точно понять, что в `map` действительно есть значение, хранящееся по переданному ключу, необходимо использовать специальный синтаксис. А именно, возвращать не только само значение, но и булевую переменную, которая показывает удалось-ли получить значение по ключу.

#### Как происходит поиск по ключу в map?

Настоятельно советую почитать более подробно об этом процессе, а также посмотреть код исходников go. По моей практике, интервьюеру всегда хватало такого ответа (просьба учитывать, что опущено множество важных деталей):

- вычисляется хэш от ключа;
- с помощью значения хэша и размера `bucket` вычисляется используемый для хранения `bucket`;
- вычисляется дополнительный хэш - это первые 8 бит уже полученного хэша;
- в полученном `bucket` последовательно сравнивается каждый из 8 его дополнительных хэшей с дополнительным хэшем ключа;
- если дополнительные хэши совпали, то получаем ссылку на значение и возвращаем его;
- если дополнительные хэши не совпали, и в `bucket` больше нет дополнительных хэшей, алгоритм переходит в следующий `bucket`, ссылка на который хранится в текущем;
- если в текущем `bucket` нет ссылки на следующий `bucket`, а значение так и не найдено, возвращается дефолтное значение.

### Как реализовано ООП в go?

В go нет классической реализация ООП, так как он не объектно-ориентированный язык. При этом в go есть свои приближения к этой реализации.

#### Наследование

Есть структуры - это специальные типы, в которые мы можем включать другие типы, в том числе такие же структуры. При этом методы дочерних структур родительская структура также будет наследовать.

> _Что будет, если и в родительской и дочерней структуре есть реализация методов с одинаковым названием?_ – Реализация родительского метода будет переписана реализацией дочернего метода

```go
type Parent struct{}

func (c *Parent) Print() {
	fmt.Println("parent")
}

type Child struct {
	Parent
}

func (p *Child) Print() {
	fmt.Println("child")
}

func main() {
	var x Child

	x.Print()
}
```

> `Child`

#### Инкапсуляция

Инкапсуляция в go - это возможность задавать переменным, функциям и методам первую букву названия в верхнем или нижнем регистре. Соответственно нижний регистр будет значить, что переменная, функция или метод доступна только в рамках пакета. Тогда как верхний регистр даст доступ к переменной, функции или методу за рамками пакета.

#### Полиморфизм

Полиморфизм в go реализован с помощью интерфейсов.

### Операторы в Go
#### Можно ли выполнить несколько условий в одном объявленном операторе *switch case*?

Такое возможно благодаря ключевому слову `fallthrough`. Оно заставляет выполнять код в следующей объявленной булевой секции, вне зависимости подходит ли булевое условие `case` этой секции.

## Интерфейсы в Golang
### Что такое интерфейсы в go?

Интерфейс – контракт, что тот или иной объект будет реализовывать указанное в интерфейсе поведение.

### Что такое пустой интерфейс?

Исходя из определения интерфейса, пустой интерфейс - это интерфейс, для реализации которого не нужно описывать ни одного метода. Таким образом, пустому интерфейсу соответствует абсолютно любой тип.

### Что такое nil интерфейс?

Интерфейс реализован в go, как структура, которая содержит в себе ссылку на само значение и ссылку на структуру `itab`.  `itab` предоставляет служебную информацию об интерфейсе и базовом типе.

Когда интерфейс `nil` значит, что интерфейс не ссылается на какое либо значение, но при этом содержит в себе служебную информацию поля `itab`. По этой причине булево сравнение `nil` с интерфейсом всегда ложное.

### Как преобразовать интерфейс к другому типу?

Интерфейс можно преобразовать в базовый тип значения (скастить). Для этого используется синтаксис, возвращающий две переменные, одна из которых булевая.

В случае, если не удалось скастить интерфейс, булевая переменная будет ложной, а переменная базового типа, к которому приводим интерфейс будет равна дефолтному значению этого типа.

```go
var (
	v string
	ok bool
)

v, ok = i.(T)
```

### Как определить тип интерфейса?

С помощью инструкции `switch case` можно определить тип интерфейса, указав возможные варианты базового типа его значения.

## Инструкция defer
### Зачем используется ключевое слово defer в go?

В Go есть ключевое слово defer, которое позволяет отложить выполнение метода до выхода их функции.

### Как передаются значения в функции, перед которыми указано ключевое слово defer?

Аргументы функций, перед которыми указано ключевое слово `defer` оцениваются немедленно. То есть на тот момент, когда переданы в функцию.

## Конкуретность
### Горутины

Горутина (goroutine) — это функция, выполняющаяся конкурентно с другими горутинами в том же адресном пространстве. Легковесны, потому что **они управляются рантаймом языка, а не операционной системой**.
#### Преимущества горутин:

1. Они легковесны. Их называют легковесными потоками, потому что **они управляются рантаймом языка, а не операционной системой**. Стоимость переключения контекста и расход памяти намного ниже, чем у потоков ОС.
2. Легко и без проблем масштабируют.
3. Требуют меньше памяти (2KB).

Каждая Машина работает в отдельном потоке и способна выполнять только одну Горутину в момент времени.
#### Что происходит при написании go?

1. **`runtime.newproc(fn)`**:
	1. Получаем текущий процессор и текущюю горутину
	2. Создаем новую горутину
	3. Вешаем нашу целевую функцию на горутину
	4. Добавить горутину в массив горутин
	   
	   Ничего не запускается!
2. **`schedule()`**
	1. Проверяем нужно ли выполнить сборку мусора.
	2. Берем горутину из нашей текущей очереди на нашем треде.
	3. Если в текущей очереди на нашем треде ничего нету, то мы либо "крадем" горутину из дргуих тредов либо ждем.

#### Как завершить много горутин?

Несколько методов:

1. **Использование канала для завершения**: Один из распространенных способов - это использовать канал для уведомления горутин о завершении. Вы можете создать канал и передать его каждой горутине. Когда горутина завершается, она может отправить сообщение в канал. Главная горутина может ожидать, когда все горутины завершатся, считывая из канала.
2. **Использование контекста для отмены**: Вы также можете использовать контекст для управления завершением горутин. Вы создаете контекст и передаете его каждой горутине. Когда вы хотите завершить все горутины, вы отменяете контекст, и горутины могут проверить отмену и завершить свою работу.
#### Горутины и потоки разница

| Потоки                                                                                              | Горутины                                                                                                                              | 
| --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| Потоки ОС управляются ядром ОС                                                                      | Горутины управляются "рантаймом" Go                                                                                                   |
| Потоки ОС в основном имееют фиксированый размер в 1-2MB                                             | Горутины обычно имеют размер стэка 2KB                                                                                                |
| Размер стэка определяется во время компиляции и не может увеличиватся                               | Размер стэка определяется во время рантайма и может расти вплоть до 1GB что возможно благодаря аллокации и освобождения места из хипа |
| У потоков нету простого способа коммуникации между собой. Такая коммуникация имеет большую задержку | Горутины используют "каналы" для быстрого общения между собой с маленькой задержкой                                                   |
### Scheduler

М - Машина
G – Горутина
P - Процессор

**Цель планировщика (scheduler)** в том, чтобы распределять готовые к выполнению горутины (G) по свободным машинам (M).

Готовые к исполнению горутины выполняются в порядке очереди, то есть FIFO (First In, First Out). Исполнение горутины прерывается только тогда, когда она уже не может выполняться: то есть из-за **системного вызова** или использования **синхронизирующих объектов** (операции с каналами, мьютексами и т.п.). 

Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась в очередь. Чтобы позволить планировщику сделать это, нужно самостоятельно вызвать `runtime.Gosched()`.
#### Как работает планировщик? 

Внутри функции **`schedule()`**:
1. Проверяем нужно ли выполнить сборку мусора.
2. Берем горутину из нашей текущей очереди на нашем треде.
3. Если в текущей очереди на нашем треде ничего нету, то мы либо "крадем" горутину из дргуих тредов либо ждем.

![](golang-scheduler.png)
#### Многозадачность в Golang

Теперь как в ОС – не кооперативная (вытесняющяя) многозадачность.

#### Состояния Горутин

Точно так же, как потоки, у горутин есть те же три состояния высокого уровня. Они определяют роль, которую планировщик Go играет с любой горутиной. Горутина может находиться в одном из трех состояний: 
  
- **Ожидание**: это означает, что горутина остановлена и ждет чего-то, чтобы продолжить. Это может происходить по таким причинам, как ожидание операционной системы (системные вызовы) или синхронизация вызовов (атомарные и мьютексные операции). Эти типы задержек являются основной причиной плохой производительности.  
- **Готовность**: это означает, что горутина хочет получить время, чтобы выполнить назначенные инструкции. Если у вас много горутин, которым нужно время, то горутине придется ждать дольше, чтобы получить время. Кроме того, индивидуальное количество времени, которое получает любая горутина, сокращено, поскольку больше горутин конкурируют за время. Этот тип задержки планирования также может быть причиной плохой производительности.  
- **Выполнение**: это означает, что горутина была помещена в M и выполняет свои инструкции. Работа, связанная с приложением, завершена. Это то, что все хотят.
#### Ограничения планировщика

1. LIFO
2. Нету гарантии времени выполнения.
3. Горутины перемещаются между тредами – снижение эффективности кэшей.
### Каналы

Виды:
- Буферизированный (кидаем пока есть пространство)
- Небуферизированный (сразу лочится)
#### Буферизированный канал

Обычно каналы работают синхронно - каждая из сторон ждёт, когда другая сможет получить или передать сообщение. Но буферизованный канал работает асинхронно — получение или отправка сообщения не заставляют стороны останавливаться. Но канал теряет пропускную способность, когда он занят, в данном случае, если мы отправим в канал 1 сообщение, то мы не сможем отправить туда ещё одно до тех пор, пока первое не будет получено.
### WaitGroups

Это механизм синхронизации в языке программирования Go (Golang), который позволяет дождаться завершения выполнения нескольких горутин (concurrent goroutines) перед продолжением выполнения основной программы.

WaitGroup имеет три основных метода:

1. `Add(delta int)`: Инкрементирует счетчик WaitGroup на значение `delta`. Обычно используется перед запуском каждой горутины.
    
2. `Done()`: Декрементирует счетчик WaitGroup на 1. Обычно вызывается в конце выполнения каждой горутины, чтобы указать, что она завершила свою работу.
    
3. `Wait()`: Блокирует выполнение программы до тех пор, пока счетчик WaitGroup не станет равным нулю. Этот метод используется в основной горутине, чтобы ожидать завершения всех других горутин.

### Graceful shutdown

Корректное и безопасное завершение работы программы или сервиса, позволяя всем активным операциям завершиться перед выходом. Это особенно важно для серверных приложений, чтобы избежать потери данных или состояния.

Можно создать канал, который будет принимать значения `SIGINT` (Ctrl+C) или `SIGTERM` (посылаются при выполнении команды `kill`). И при получении его `server.shutdown()`.
## Другие
### Что такое захват переменной?

В функциональных языках программирования переменные, определенные внутри функции, могут иметь доступ к переменным из внешней области видимости. Когда функция захватывает переменную из окружающего контекста, она сохраняет доступ к этой переменной даже после завершения выполнения функции. Это позволяет использовать значения переменных из внешнего контекста внутри функции даже после того, как эта функция была вызвана.

### Где используется контекст?

1. Таймауты
2. Отмена операций (напр., горутин)

### Generics

Generics - это концепция языков программирования, которая позволяет писать функции и структуры данных, не привязываясь к конкретным типам данных, а вместо этого параметризуя их типами.

То есть можно писать функции для разных типов данных. Это как шаблоны в С++.

### Объявление переменных – разница
#### Map
Если объявить так: `var m map[string]int` и  потом присвоить значение, то будет паника.

#### Slice
Если в пустой слайс загонять через `append`, то все нормально. Если в пустой слайс, где нету еще *capacity*, то будет паника.

### Мьютексы

Механизм синхронизации, который используется для обеспечения доступа к общим данным из нескольких горутин.

Два основных:
1. **sync.Mutex**: Это классический мьютекс для обеспечения взаимного исключения. Он блокирует доступ к общим данным, позволяя только одной горутине захватить его одновременно.
2. **sync.RWMutex**: Это мьютекс с поддержкой чтения/записи (read-write lock). Он позволяет нескольким горутинам читать данные одновременно, но блокирует доступ для записи в тот момент, когда кто-то уже читает или пишет.

### Тестирование
Table test
В Школе использовал модуль `testing`, `testify mock`.

### Protobuf
Protocol Buffers — протокол сериализации структурированных данных, предложенный Google как эффективная бинарная альтернатива текстовому формату XML.

### gRPC
gRPC (gRPC Remote Procedure Call) - это высокопроизводительный протокол удаленного вызова процедур, разработанный компанией Google. Он представляет собой современную альтернативу для традиционных протоколов удаленного вызова, таких как SOAP или REST.

SOTA Resources

1. go.dev
2. gobyexample
3. ....

Основное API. Как с ними работать? gotour.

Что такое context switch?

Graceful shutdown
Context



[Channel Axioms | Dave Cheney](https://dave.cheney.net/2014/03/19/channel-axioms)
[Scheduling In Go : Part I - OS Scheduler](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)
[Как на самом деле устроен тип Map в Golang? | Golang под капотом - YouTube](https://www.youtube.com/watch?v=P_SXTUiA-9Y)
[Before you continue to YouTube](https://www.youtube.com/@Skills_mentor/videos)
[ТОП вопросов на Go собеседовании | Вопросы и задачи с реальных собеседований - YouTube](https://www.youtube.com/watch?v=hJ3Y_8Zhju8)
[Golang-Senior-Developer-Interview - Arkusze Google](https://docs.google.com/spreadsheets/d/1U6AEqXkvXz5tzsBATd-1D_o_8NHwkNKOxJiwDwkEzvY/edit?pli=1#gid=0)
[Антон Сергеев, «Go под капотом» - YouTube](https://www.youtube.com/watch?v=rloqQY9CT8I)
[Полезные ресурсы для изучающих Go · GitHub](https://gist.github.com/sam65536/0972422f51cfb790c889a3a026d605d6)
[Мой опыт технического собеседования: как не превратить его в экзамен и найти профпригодного сотрудника](https://itnan.ru/post.php?c=1&p=645717)

[Awesome Software Architecture](https://awesome-architecture.com/)
