# Message Brokers

```table-of-contents
```

## to-do

- и про ребалансировку и нахуй она и когда делается
- куда продюсер писать может?
- вот у нас 3 реплики
- куда он пишет?
- loose coupling event driven
- exactly-once kafka
- Idempotency Keys kafka
- Как подтверждать, что был отправлен и успешно принята какая-то ифна?

## Message Queues & Message Brokers

Брокеры сообщений используют очереди сообщений, чтобы передавать информацию. То есть MQ – это струтура данных, которая хранит что-то, а брокер – это софтина, которая управляет этим.

### Очереди

Очередь — структура данных с дисциплиной доступа к элементам «первый пришёл — первый вышел». Добавление элемента возможно лишь в конец очереди, выборка — только из начала очереди, при этом выбранный элемент из очереди удаляется.

### Брокеры сообщений

Брокер сообщений представляет собой тип построения архитектуры, при котором элементы системы «общаются» друг с другом с помощью посредника. Благодаря его работе происходит ***снятие нагрузки с веб-сервисов***, так как им не приходится заниматься пересылкой сообщений: всю сопутствующую этому процессу работу он берёт на себя.

| Преимущества                                                                                                                       | Недостатки                                |
| ---------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------- |
| Асинхронная коммуникация                                                                                                           | Нужно управление по мониторингу           |
| Отказоустойчивость (fault tolerance)                                                                                               | Дополнительная задержка                   |
| Гарантии доставки (обеспечивает различные уровни гарантий доставки, включая "хотя бы один раз" и "ровно один раз")                 | Зависимость от работы брокера             |
| Гибкость в маршрутизации  (можно динамически изменять пути сообщений и фильтровать сообщения на основе содержимого или заголовков) | Дополнительные требования к ресурсам      |
| Масштабируемость                                                                                                                   | Дополнительные требования по безопасности |

### Когда брокеры сообщений могут быть полезны

- Действия с задержкой, которые не требуют результата сейчас.
- Координация микросервисов.

### Семантики доставки

- **At-most-once delivery** – сообщение не может быть доставлено больше одного раза. При этом сообщение может быть потеряно.
- **At-least-once delivery** – сообщение никогда не будет потеряно. При этом сообщение может быть доставлено более одного раза.
- **Exactly-once delivery**. Все сообщения доставляются строго единожды.

![semantics-delivery](semantics-delivery.png)

На первый взгляд самой правильной для любого приложения кажется семантика **exactly once**, однако это не всегда так. Например, при передаче партнёрских координат вовсе не обязательно сохранять каждую точку из них, и вполне хватит at-most once. А при обработке идемпотентных событий нас вполне может и устроить дубль, если статусная модель предполагает его корректную обработку.

В распределённых системах у exactly-once есть своя цена: *высокая надёжность* означает *большие задержки*.

**End-to-end idempotence** – даже при многократной попытке записи или обработки сообщения, в системе будет гарантировано, что сообщение будет обработано точно один раз:

- продьюсеры не будут писать больше одного раза
- консьюмеры будут читать только один раз даже при сбоях

> [!info] 
> В транзакциях kafka можно сделать, чтобы несколько ивентов схлопались в один


### Вопросы на интервью
#### Можно ли вычитывать сообщения разными консьюмерами из одной партиции?

Обычно рекомендуется иметь не более одного консьюмера из одной и той же группы консьюмеров, читающего из одной партиции. Это обеспечивает упорядоченное чтение в рамках партиции.

Технически возможно иметь несколько консьюмеров из разных групп консьюмеров, читающих из одной и той же партиции. Однако это может привести к дублированию сообщений для разных групп консьюмеров.

#### Что если отправитель и получатель пишут много сообщений, попали в одну партицию?

Отправить их в отдельную партицию

#### Можно ли потерять сообщение, когда его отправили в очередь?


## RabbitMQ

- producers
- exchanges (how messages are routed—provide a great deal of flexibility)
- queues
- consumers

A producer pushes messages to an exchange, which then routes messages to queues (or other exchanges). A consumer then continues to read messages from the queue, often up to a predetermined limit of messages.

Producers add data to the tail of the queue; consumers receive data from the head of the queue. The queues are “first in, first out” with RabbitMQ: the first message in the queue is consumed first.

### Преимущества RabbitMQ


## RabbitMQ vs Kafka

#### Сценарии использования

- **Kafka** подходит для сценариев, где данные передаются между компонентами в виде непрерывных потоков событий, а также для аналитики в реальном времени (больше похожа на шину, чем на очередь).
- **RabbitMQ** хорошо подходит для сценариев, где необходимо гарантировать доставку сообщений в определенном порядке и обеспечить независимость компонентов друг от друга.

#### Сохранение сообщений

- **Kafka** сохраняет сообщения на определенное время (или скорее на любое время в объеме, на который хватит размера хранилища). Это позволяет обрабатывать и анализировать данные в любой момент времени, даже после их передачи.
- **RabbitMQ** хранит сообщения в очередях до тех пор, пока получатель их не обработает и подтвердит. После сообщение удаляется.

#### Порядок сообщений

- Kafka: не гарантирует
- RabbitMQ: гарантирует

#### Модели доставки

- Kafka добавляет сообщение в журнал, и консьюмер сам забирает информацию из топика
- RabbitMQ самостоятельно отправляет сообщения получателям — помещает событие в очередь и отслеживает его статус.

### Гарантии доставки в Kafka vs RabbitMQ

#### Гарантии доставки в RabbitMQ

- надежностью сообщений — они не пропадут, пока хранятся на RabbitMQ;
- уведомлениями о сообщениях — RabbitMQ обменивается сигналами с отправителями и получателями.

#### Гарантии доставки в Kafka

- долговечность сообщений — сообщения, сохранённые в сегменте, не теряются;
- уведомлениями о сообщениях — обмен сигналами между Kafka (и, возможно, хранилищем Apache Zookeeper) с одной стороны и источником/получателем — с другой.

*References:*

- [Apache Kafka и RabbitMQ: семантика и гарантия доставки сообщений](https://habr.com/ru/company/itsumma/blog/437446/)
- [RabbitMQ против Kafka: два разных подхода к обмену сообщениями](https://habr.com/ru/company/itsumma/blog/416629/)
- [Kafka VS RabbitMQ](https://medium.com/@vozerov/kafka-vs-rabbitmq-38e221cf511b)

---
## Паттерны для брокеров

### Request-Reply (Запрос-Ответ)

- **Описание**: Этот паттерн представляет собой двухстороннюю коммуникацию, где один компонент (запрашивающий) отправляет запрос, а другой (отвечающий) получает запрос и отправляет ответ обратно.
- **Применение**: Широко используется в синхронных операциях, где требуется немедленный ответ, например, в веб-сервисах или при удаленном вызове процедур (RPC).
- **Технология**: HTTP/HTTPS, gRPC, Apache Thrift

### Publish-Subscribe (Публикация-Подписка)

- **Описание**: В этом паттерне издатель (publisher) отправляет сообщения без указания конкретного получателя, а подписчики (subscribers) получают сообщения на основе своих подписок.
- **Применение**: Используется для рассылки уведомлений, широковещательной коммуникации и в сценариях, где одно сообщение должно быть доставлено многим получателям.
- **Технология**: Apache Kafka, RabbitMQ, MQTT

### Synchronous (Синхронный)

- **Описание**: Синхронная передача данных требует, чтобы отправитель ожидал ответа после отправки каждого сообщения.
- **Применение**: Подходит для сценариев, где важна тесная связь между отправкой запроса и получением ответа, например, в запросах к базе данных или при обработке транзакций.
- **Технология**: Традиционные веб-сервисы, SQL базы данных

### Asynchronous (Асинхронный)

- **Описание**: В асинхронном обмене сообщениями отправитель не ожидает немедленного ответа и может продолжать свою работу независимо от того, обработано ли сообщение получателем.
- **Применение**: Асинхронные паттерны идеально подходят для фоновой обработки, длительных задач, обмена сообщениями в системах с высокой пропускной способностью и низкой задержкой.
- **Технология**: AMQP, Amazon SQS, Node.js

### Competing Consumers (Соревнующиеся Потребители)

- **Описание**: В этом паттерне несколько потребителей (consumers) прослушивают одну и ту же очередь сообщений, и когда сообщение поступает, один из потребителей выбирается для его обработки.
- **Применение**: Эффективен для масштабирования обработки сообщений, распределяя нагрузку между несколькими экземплярами потребителей.
- **Технология**: RabbitMQ, Apache Kafka
### Work Queues (Очереди Работы)

- **Описание**: Распределение задач между несколькими рабочими процессами, где каждая задача обрабатывается один раз одним рабочим процессом.
- **Применение**: Подходит для распределённой обработки задач, когда задачи могут быть независимо выполнены различными рабочими процессами.
- **Технология**: Celery (с использованием RabbitMQ или Redis)

### Message Routing (Маршрутизация Сообщений)

- **Описание**: Определение правил или критериев для маршрутизации сообщений по различным путям или в разные очереди.
- **Применение**: Используется для управления потоком данных в системе, например, для фильтрации, агрегации или преобразования сообщений.
- **Технология**: Apache Camel, Mule ESB

### Scatter-Gather (Разброс-Сбор)

- **Описание**: Отправка запроса нескольким получателям и последующий сбор и агрегация ответов.
- **Применение**: Подходит для ситуаций, когда необходимо выполнить параллельные запросы и собрать результаты, например, для агрегации данных из нескольких источников.
- **Технология**: Apache Kafka, Apache Spark

### Fan-out/Fan-in (Разветвление/Схождение)

- **Описание**: Распространение сообщения на несколько получателей (fan-out) и последующее схождение результатов обработки (fan-in).
- **Применение**: Эффективен для параллельной обработки и последующей агрегации результатов.
- **Технология**: AWS Lambda, Google Cloud Functions

[Cloud design patterns - Azure Architecture Center | Microsoft Learn](https://learn.microsoft.com/en-us/azure/architecture/patterns/)