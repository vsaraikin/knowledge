# Architecture

```table-of-contents
```
## Микросервисы и монолиты

### Что такое монолитная архитектура (её плюсы и минусы)?

Монолитная архитектура — это традиционная модель программного обеспечения, которая представляет собой единый модуль, работающий автономно и независимо от других приложений.

| Плюсы                                  | Минусы                                             |
| -------------------------------------- | -------------------------------------------------- |
| Быстрый старт и развертывание          | Дольше разрабывать большой проект                  |
| Общий codebase                         | Невозможно масштабировать                          |
| Меньше API вызовов (т.к. общий проект) | Сложнее использовать другую технологию             |
|                                        | Перезапуск всего приложения при внесении изменений |

### Что такое микросервисная архитектура (её плюсы и минусы)?

Микросервисная архитектура представляет собой метод организации архитектуры, основанный на ряде независимо развертываемых служб. У этих служб есть собственная бизнес-логика и база данных с конкретной целью.

| Плюсы                                  | Минусы                                               |
| -------------------------------------- | ---------------------------------------------------- |
| Гибкость с технологиями                | Дорого                                               |
| Отказоустойчивость                     | Сложнее дебажить                                     |
| Локализуются сложность и риски отказов | Сложности развёртывания (сложнее локально запустить) |
| Масштабируемость                       |                                                      |

### Как происходит переход от монолитной архитектуры к микросервисной?

Опция 1. Постепенное отпочковывание микросервисов и написание новой функциональности уже отдельно от основного приложения. Подход хороший и рабочий, но имеет один существенный недостаток — основное монолитное приложение в обозримом будущем не исчезнет. В итоге у нас будет монолит и куча вспомогательных сервисов, вместо набора независимых микросервисов.

## Паттерны проектирования

### Порождающие (creational)

Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.

**[Абстрактная фабрика](https://refactoring.guru/ru/design-patterns/abstract-factory)** — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

![abstract-factory](abstract-fabric.png)

[Code](https://refactoring.guru/ru/design-patterns/abstract-factory/python/example)

**[Прототип](https://refactoring.guru/ru/design-patterns/prototype)** — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.

![prototype](prototype.png)

[Code](https://refactoring.guru/ru/design-patterns/prototype)

### Структурные (structural)

Отвечают за построение удобных в поддержке иерархий классов.

**[Декоратор](https://refactoring.guru/ru/design-patterns/prototype)** — это структурный паттерн, который позволяет добавлять объектам новые поведения на лету, помещая их в объекты-обёртки.

[Code.](https://refactoring.guru/ru/design-patterns/decorator)

[**Заместитель (proxy)](https://refactoring.guru/ru/design-patterns/proxy)** — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то *до* или *после* передачи вызова оригиналу.

[Code.](https://refactoring.guru/ru/design-patterns/proxy/python/example)

### Поведенческие (behavioural)

Решают задачи эффективного и безопасного взаимодействия между объектами программы.

**[Итератор](https://refactoring.guru/ru/design-patterns/iterator)** — это поведенческий паттерн, позволяющий последовательно обходить сложную коллекцию, без раскрытия деталей её реализации.

[Code.](https://refactoring.guru/ru/design-patterns/iterator/python/example)

**[Стратегия](https://refactoring.guru/ru/design-patterns/strategy)** — это поведенческий паттерн, выносит набор алгоритмов в собственные классы и делает их взаимозаменимыми.

[Code.](https://refactoring.guru/ru/design-patterns/strategy/python/example)

## Паттерны микросервисов

### Saga

Сага с компенсирующими транзакциями

### [Pattern: Transactional outbox](https://microservices.io/patterns/data/transactional-outbox.html)

Идея:

Есть локальный сторадж с аутбоксом для коммуникации между сервисами.
![](Architecture.png)

- письмо отправлено один раз

Боксы:

- exactly-once
- 

### Inbox

- письмо за процесснуто один раз

## Clean architecture

Controller – это то, что у нас лежит обычно в handler.go как самый верхний уровень fasthttp ручки.
UseCase – это то, что лежит у нас обычно в service.go.
Repository – это что в нашем случае? что-то типо GetInstrumentByUID?


## DDD

[Все о микросервисах](https://microservices.io/)

[Зачем нужен паттерн database per service | Эйч Навыки | Менторство по Go - YouTube](https://www.youtube.com/watch?v=XefGw2hO3kI)
[Собеседование на Go-разработчика, System Design - YouTube](https://www.youtube.com/watch?v=cTHGqKgKBUA)