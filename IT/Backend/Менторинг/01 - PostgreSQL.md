# PostgreSQL

## Общее

**OLTP** системы предназначены для обработки большого количества кратковременных транзакций в реальном времени. Они широко используются в операционных системах, таких как системы управления заказами, банковские системы, системы бронирования и т.д.

- PostgreSQL
- MySQL

**OLAP** системы предназначены для выполнения сложных аналитических запросов, которые обычно используются для поддержки принятия решений в бизнесе. Они применяются в системах бизнес-аналитики, отчетности и анализа данных.

- Oracle OLAP
- Tableau

### Relations

Отношения – это по фатку любые объекты в PG:
- Tables
- Indexes
- View
- Materialised View
- Sequence

#### VIEW vs MATERIALIZED

- VIEW не хранит данные в себе
-  MATERIAZILZED её кэширует

## MVCC

Multiversion concurrency control

- Есть два вида БД: те, что блокируются и версионируются
- Каждая транзакция характеризуется некоторым id-шником. Id-шники транзакций монотонно растут. У любой строчки есть 2 атрибута, которые представляют метаинформацию для обеспечения механизма: updated_by_id — id-шник транзакции, которая последней осуществила обновление этой записи и deleted_by_id — id-шник транзакции, которая удалила данную запись.

| Преимуещества                              | Недостатки                 |
| ------------------------------------------ | -------------------------- |
| Параллелизм (с помощью изоляции снэпшотом) | Раздувание и сборка мусора |
| Нет блокировок                             |                            |

## MVCC Advanced

### Слои (forks) и файлы

Каждому отношению соответствует несколько _слоев_ (forks). Слои бывают нескольких типов и каждый из них содержит определенный вид данных.

Если слой есть, то вначале он представлен одним-единственным _файлом_. Имя файла состоит из числового идентификатора, к которому может быть добавлено окончание, соответствующее имени слоя.  
  
Файл постепенно растет и, когда его размер доходит до 1 ГБ, создается следующий файл этого же слоя (такие файлы иногда называют _сегментами_). Порядковый номер сегмента добавляется в конец имени файла.

Файлы, в свою очередь, разделены на _страницы_ (или _блоки_), обычно по 8 КБ.

![forks-postgresql](forks_postgresql.png)


### Страницы

Файлы логически поделены на страницы.

### Заголовок

каждая строка может одновременно присутствовать в базе данных в нескольких версиях.

Одну версию от другой надо как-то отличать С этой целью каждая версия имеет две отметки, определяющие «время» действия данной версии (xmin и xmax).

### Как происходит обновление данных?

1. Начинаем транзакцию
2. Получаем ID транзакции
3. 

### Версии строк

Версия строки — это конкретное состояние строки таблицы в определенный момент времени, связанное с транзакцией, которая эту строку создала или изменила.

#### Поля, определяющие версию строки:

1. **xmin** — номер транзакции, создавшей строку.
2. **xmax** — номер транзакции, удалившей строку (или обновившей, что эквивалентно удалению старой версии и вставке новой).
3. **ctid** — уникальный идентификатор строки, который указывает на текущую версию строки.

### Снимки данных

Снимок данных (snapshot) — это механизм, используемый для обеспечения изоляции транзакций. 

Он позволяет каждой транзакции видеть согласованное состояние базы данных на определенный момент времени. Этот снимок содержит только те данные, которые были зафиксированы до момента создания снимка, и исключает еще не зафиксированные данные.

#### Как работают снимки данных?

- **Read Committed**: Снимок создается в начале каждого оператора транзакции и остается активным, пока выполняется оператор.
- **Repeatable Read и Serializable**: Снимок создается один раз в начале первого оператора транзакции и остается активным до конца транзакции.

#### Видимость строк в снимке данных

Видимость версии строки в снимке определяется двумя полями заголовка строки: `xmin` (номер транзакции, создавшей строку) и `xmax` (номер транзакции, удалившей строку). Строка видна, если транзакция, создавшая ее, завершилась до создания снимка, и транзакция, удалившая ее, еще не завершилась.

### Горизонт событий

Граница, за которой все транзакции, начавшиеся до определенного момента, завершены.

Зачем нужен?

- Поддержание актуальности данных и удаление мертвых строк важно для поддержания высокой производительности базы данных.
- Долгоживущие транзакции должны быть минимизированы или избегаться, чтобы не задерживать продвижение горизонта событий.


### Autovacuum

По умолчанию есть шедулер, который выполняет VACUUM не блокируя другие операции.

**Основные параметры:**

- `autovacuum_vacuum_threshold`
- `autovacuum_vacuum_scale_factor`
- `autovacuum_analyze_threshold`
- `autovacuum_analyze_scale_factor`

### Метаинформация

1. **Системные каталоги**:
    
    - `pg_class`: Хранит информацию о таблицах, индексах и других объектах.
    - `pg_stat_all_tables`: Содержит статистику по всем таблицам, включая количество вставок, обновлений, удалений и т.д.
    - `pg_stat_all_indexes`: Содержит статистику по всем индексам.
    - `pg_attribute`: Содержит информацию о столбцах таблиц.
      
2. **Free Space Map (FSM)**:
    
    - Карта свободного пространства отслеживает свободные места внутри каждого файла таблицы, что позволяет быстрее находить подходящее место для новых вставок.
      
3. **Visibility Map (VM)**:
    
    - Карта видимости указывает, какие страницы содержат только видимые строки. Это помогает ускорить операции VACUUM и индексацию.

#### Как это связано с MVCC?

FSM и VM помогают эффективно управлять ресурсами хранения, обеспечивая быстрый доступ к свободным и видимым строкам. MVCC создает множество версий строк, и эти карты помогают минимизировать затраты на управление ими.

#### Что происходит с метаинформацией при обновлении таблиц в PG?

1. **Системные каталоги**:
    
    - **pg_class**: Обновляется информация о таблицах, включая количество мертвых строк (`reltuples`), и общее количество строк в таблице (`relpages`).
    - **pg_stat_all_tables**: Обновляется статистика, такая как время последнего выполнения VACUUM, количество мертвых строк и количество обновленных строк.
    - **pg_stat_all_indexes**: Обновляется информация об индексах, включая статистику по операциям вставки, обновления и удаления.
      
2. **Файлы FSM и VM**:
    
    - **Free Space Map (FSM)**: Обновляется, чтобы отразить освобождение пространства в таблицах. FSM отслеживает свободное пространство внутри каждого файла таблицы, что позволяет новым вставкам быстро находить подходящее место.
    - **Visibility Map (VM)**: Обновляется, чтобы пометить страницы, где все строки видимы и больше не требуют проверки на видимость. Это помогает ускорить последующие операции VACUUM и другие операции чтения.
      
3. **Обновление индексов**:
    
    - Индексы очищаются от ссылок на мертвые строки. Это происходит в фоне и помогает поддерживать быстродействие индексов.

## Уровни изоляции

**"Грязное" чтение**: Транзакция читает данные, записанные параллельной незавершённой транзакцией.

**Неповторяемое чтение**: Транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изменены другой транзакцией (которая завершилась после первого чтения).

**Фантомное чтение**: Транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия, и обнаруживает, что набор строк, удовлетворяющих условию, изменился из-за транзакции, завершившейся за это время.

**Аномалия сериализации**: Когда невозможно предсказать в каком порядке выполнятся транзакции. Важно, когда берем проценты от числа.

- 1000 * 110% + 1000 = 2100
- (1000 + 1000) * 110% = 2200
## Индексы

### Общее

#### Уникальные индексы

```sql
CREATE UNIQUE INDEX
```

Будет хранить значения только уникальные.

#### Индексы на основе выражений

```sql
CREATE UNIQUE INDEX aircrafts_unique_model_key
  ON aircrafts ( lower( model ) );
```

#### Частичные индексы

```sql
CREATE INDEX bookings_book_date_part_key
  ON bookings ( book_date )
  WHERE total_amount > 1000000;
```

Частичные индексы выглядят очень привлекательно, но в большинстве случаев их преимущества по сравнению с обычными индексами будут минимальными. Однако размер частичного индекса будет меньше, чем размер обычного.

### B-Tree 

1. сбалансированное дерево — это древовидная структура данных, в которой узлы отсортированы и сбалансированы таким образом, чтобы все пути от корня до листьев имели одинаковую длину. В каждом узле хранятся ключи и указатели на дочерние узлы.
2. При вставке нового ключа дерево автоматически перестраивается, чтобы сохранять балансировку. То же самое происходит при удалении ключа. Это обеспечивает эффективность операций поиска, вставки и удаления.
3. Поиск в B-Tree осуществляется за логарифмическое время (O(log n)), так как на каждом уровне дерева осуществляется бинарный поиск среди ключей.

### Hash

1. Каждое значение столбца преобразуется хэш-функцией в уникальный хэш-код, который указывает на позицию записи в хэш-таблице.
2. Hash индексы **подходят** только для точного поиска (например, `WHERE column = value`). Они **неэффективны** для диапазонных запросов и не поддерживают сортировку.

### GiST (Generalized Search Tree)

GiST индексы предоставляют общую инфраструктуру для реализации различных типов индексов.

1. **Структура**: GiST индексы имеют древовидную структуру, похожую на B-Tree, но более гибкую.
2. **Использование**: GiST используется для создания индексов для нестандартных типов данных, таких как геометрические и полнотекстовые данные.

### GIN (Generalized Inverted Index)

GIN индексы используются в основном для индексирования массивов и полнотекстового поиска.

1. **Структура**: GIN индексы содержат инвертированные списки, где каждому элементу (например, слову в тексте) соответствует список документов (строк), содержащих этот элемент.
2. **Применение**: Эти индексы особенно полезны для поиска по ключевым словам и тегам.

### BRIN (Block Range INdexes) 

BRIN индексы предназначены для работы с очень большими таблицами, где данные имеют физическую упорядоченность.

1. **Структура**: BRIN индексы хранят метаданные о блоках таблицы, например, минимальное и максимальное значение в блоке.
2. **Эффективность**: Они очень компактны и обеспечивают эффективный доступ к данным при условии, что данные имеют определённый порядок.

## INCLUDE INDEX

`INCLUDE`позволяет создавать ***покрывающие*** индексы, которые значительно ускоряют выполнение запросов, снижая необходимость обращения к данным в таблице.

## Селективность

Индексы более полезны, когда из таблицы выбирается лишь небольшая доля строк, т. е. при *высокой селективности выборки*.

### Как мерить селективность?

$Селективность = Общее количество строк в таблице / Количество подходящих строк​$

### Что такое селективность?

Селективность в контексте баз данных и запросов к ним — это мера того, какая доля строк из таблицы удовлетворяет определенному условию запроса. Она играет ключевую роль в выборе оптимизатором запросов наилучшего плана выполнения. Высокая селективность означает, что условие запроса фильтрует большую часть строк (например, выборка одной или нескольких строк из миллиона), тогда как низкая селективность означает, что условие запроса возвращает значительную часть таблицы (например, половину строк).

### Как измеряется селективность?

Селективность измеряется как отношение числа строк, удовлетворяющих условию, к общему числу строк в таблице. Это можно выразить следующей формулой:

$\text{Селективность} = \frac{\text{Количество подходящих строк}}{\text{Общее количество строк в таблице}}$

**Пример 1: Высокая селективность**

   ```sql
   SELECT * FROM users WHERE user_id = 12345;
   ```

   $\text{Селективность} = \frac{1}{1,000,000} = 0.000001$


**Пример 2: Низкая селективность**

   ```sql
   SELECT * FROM users WHERE country = 'USA';
   ```

   $\text{Селективность} = \frac{500,000}{1,000,000} = 0.5$

### Как выбирать индексы?

### Как грамотно создавать индексы?

## Что делать когда индексы разрослись?

### VACUUM
	
- Простая команда `VACUUM` (без `FULL`) только высвобождает пространство для текущей таблице. Не требует исключительной блокировки.
- `VACUUM FULL` переписывает всё содержимое таблицы в новый файл на диске, что позволяет возвратить неиспользованное пространство операционной системе. Эта форма работает намного медленнее и запрашивает исключительную блокировку для каждой обрабатываемой таблицы.
### CLUSTER

Процесс кластеризации перестраивает таблицу так, чтобы строки хранились в порядке, соответствующем порядку ключей индекса. 

```sql
CLUSTER my_table USING my_index;
```

### REINDEX

`REINDEX` перестраивает индекс, обрабатывая данные таблицы, к которой относится индекс, и в результате заменяет старую копию индекса. Блокирующий, но есть настрйока неблокирующая.

```sql
REINDEX INDEX CONCURRENTLY indexname1;
```
### pg_repack

[pg_repack](https://github.com/reorg/pg_repack) – расширение, которое пересобирает таблицы и индексы.  Не блокирующий!


## Explain

```sql
EXPLAIN SELECT * FROM users WHERE user_id = 12345;
```

```plaintext
Index Scan using idx_user_id on users  (cost=0.29..8.30 rows=1 width=52)
  Index Cond: (user_id = 12345)
```


1. Тип операции (Index Scan)
2. Используемый индекс (using idx_user_id)
3. Затраты (cost=0.29..8.30)
   - Startup Cost (0.29): Затраты на инициализацию операции (например, на поиск первой подходящей строки).
   - Total Cost (8.30): Общие затраты на выполнение всей операции до её завершения.
4. Количество строк (rows=1) – Оценка количества строк, которые будут возвращены этой операцией.
5. Ширина (width=52) – Средний размер строки в байтах, возвращаемой этой операцией.
6. Условие индекса (Index Cond: (user_id = 12345)) – Условие, применяемое к индексу для фильтрации строк.


## Моргунов [10.1-10.5]

### Методы доступа

Метод доступа характеризует тот способ, который используется для просмотра таблиц и извлечения только тех строк, которые соответствуют критерию отбора

#### Sequential Scan

Поиск по всей таблице по каждой строке.

Последовательное сканирование — самый эффективный способ прочитать всю таблицу или значительную ее часть. Иными словами, последовательное сканирование хорошо работает при низкой селективности. (При высокой селективности, когда из всей таблицы нужна только небольшая часть строк, более предпочтительным будет использование индекса.)

##### Когда:

- Нет подходящего индекса для использования.
- Запрос затрагивает большую часть таблицы (например, возвращает более 30-50% строк), и использование индекса не даст существенного выигрыша, то есть низкая селективность
- Таблица мала, и затраты на построение индекса не оправданы.

#### Index Scan

Поиск по индексу.
##### Когда:

- Есть индекс, подходящий для условий запроса.
- Запрос возвращает небольшое количество строк, то есть высокая селективность.
- Требуется быстро найти строки по значению одного или нескольких столбцов.

>[!cite]
>В таком случае при низкой селективности выборки, т. е. когда из таблицы отбирается значительное число строк, использование индексного поиска может не только не давать ускорения работы, но даже и снижать производительность.

#### Index only scan

Похоже на обычное сканирование индекса, но без обращения к самой таблице. Используется, когда все данные для запроса содержатся в индексе.

>[!cite]
>Все индексы в Postgres Pro являются _вторичными_, что значит, что каждый индекс хранится вне области основных данных таблицы (_куча_ таблицы).
>
>Это значит, что при обычном сканировании индекса для извлечения каждой строки необходимо прочитать данные <u>и из индекса, и из кучи</u>. Более того, тогда как элементы индекса, соответствующие заданному условию `WHERE`, обычно находятся в индексе рядом, строки таблицы могут располагаться в куче произвольным образом. Таким образом, обращение к куче при поиске по индексу влечёт множество операций произвольного чтения кучи, которые могут обойтись недёшево, особенно на традиционных вращающихся носителях
>
>Чтобы решить эту проблему с производительностью, Postgres Pro поддерживает _сканирование только индекса_, при котором результат запроса может быть получен из самого индекса, без обращения к куче.

##### Когда

- Индекс покрывает все столбцы, необходимые для запроса.

#### Bitmap scan

Этот метод объединяет использование индексов и последовательное сканирование. Создаётся *битовая карта*, указывающая на нужные страницы таблицы, которые затем считываются последовательно.

>[!cite]
>Является модификацией просмотра на основе индекса. Данный метод позволяет оптимизировать индексный по- иск за счет того, что сначала производится поиск в индексе для всех искомых строк и формирование так называемой битовой карты, в которой указывается, в каких страницах таблицы эти строки содержатся. После того как битовая карта сформирована, выполняется извлечение строк из страниц таблицы, но при этом обращение к каждой странице производится только один раз.

##### Когда:

- Запрос затрагивает больше строк, чем это эффективно для обычного сканирования индекса, но меньше, чем требуется для последовательного сканирования.

### JOIN-ы строк

#### Nested loop

Для каждой строки из первой (внешней) таблицы выполняется цикл поиска соответствующих строк во второй (внутренней) таблице.

- Когда одна из таблиц очень мала.
- Когда используется индекс для доступа к строкам второй таблицы.

#### Hashing

Строится хеш-таблица на основе строк одной таблицы (внутренней), а затем для каждой строки из другой таблицы (внешней) производится поиск соответствующих строк в хеш-таблице.

**Когда используется**:

- Когда нет индексов на ключ соединения.
- Когда одна из таблиц достаточно мала, чтобы поместиться в памяти.

>[!cite]
При соединении хешированием строки одного набора помещаются в хеш-таблицу, содержащуюся в памяти, а строки из второго набора перебираются, и для каждой из них проверяется наличие соответствующих строк в хеш-таблице. Ключом хеш-таблицы является тот столбец, по которому выполняется соединение наборов строк. Как правило, число строк в том наборе, на основе которого строится хеш-таблица, меньше, чем во втором наборе. Это позволяет уменьшить ее размер и ускорить процесс обращения к ней. Данный метод работает только при выполнении эквисоедине- ний, поскольку для хеш-таблицы имеет смысл только проверка на равенство прове- ряемого значения одному из ее ключей. Метод эффективен для больших выборок.

#### Merge

Обе таблицы предварительно сортируются по ключу соединения, а затем производится линейное сканирование и объединение строк на основе ключа.

**Когда используется**:

- Когда обе таблицы отсортированы по ключу соединения.
- Когда сортировка ключей менее затратна, чем другие методы соединения.

>[!cite]
Соединение методом слияния производится аналогично сортировке слиянием. В этом случае оба набора строк должны быть предварительно отсортированы по тем столбцам, по которым производится соединение. Затем параллельно читаются строки из обоих наборов и сравниваются значения столбцов, по которым производится соединение. При совпадении значений формируется результирующая строка. Этот процесс продолжается до исчерпания строк в обоих наборах. Этот метод, как и ме- тод соединения хешированием, работает только при выполнении эквисоединений. Он пригоден для работы с большими наборами строк.

### Query Planner

Структура плана запроса представляет собой дерево, состоящее из так называемых узлов плана (plan nodes).

### Управление планировщиком

```sql
SET enable_nestloop = off;
SET enable_mergejoin = off;
SET enable_hashjoin = off;
```

Можно принудительно выбирать другой алгоритм соединения для выполнения запросов
### Оптимизация запросов

- обновление статистики, на основе которой планировщик строит планы;
- изменение исходного кода запроса;
- изменение схемы данных, связанное с денормализацией: создание материализо- ванных представлений и временных таблиц, создание индексов, использование вычисляемых столбцов таблиц;
- изменение параметров планировщика, управляющих выбором порядка соедине- ния наборов строк: использование общих табличных выражений (запросы с пред- ложением `WITH`), использование фиксированного порядка соединения (параметр `join_collapse_limit` = 1), запрет раскрытия подзапросов и преобразования их в соединения таблиц (параметр `from_collapse_limit` = 1);
- изменение параметров планировщика, управляющих выбором метода доступа к данным (`enable_seqscan`, `enable_indexscan`, `enable_indexonlyscan`, `enable_bitmapscan`) и способа соединения наборов строк (`enable_nestloop`, `enable_hashjoin`, `enable_mergejoin`);
- изменение параметров планировщика, управляющих использованием ряда операций: агрегирование на основе хеширования (`enable_hashagg`), материализация временных наборов строк (`enable_material`), выполнение явной сортиров- ки при наличии других возможностей (`enable_sort`).

>[!todo]
>В конце решить контрольные вопросы

## Блокировки

- MVCC позволяет блокироваться реже
- Гранулярность (разбивка на слои) тоже облегчает работу
- Бловировки могут быть _исключительным_ или _монопольным
- Блокировки могут быть на уровне объектов (аьаблицы, индексы, последовательности, строк и еще есть предикатные блокировки

[PostgreSQL : Документация: 10: 13.3. Явные блокировки : Компания Postgres Professional](https://postgrespro.ru/docs/postgresql/10/explicit-locking#LOCKING-TABLES)

Блокировки объектов располагаются в общей памяти сервера. Их количество ограничено произведением значений двух параметров: _max_locks_per_transaction_ × _max_connections_.  
  
Пул блокировок — общий для всех транзакций, то есть одна транзакция может захватить больше блокировок, чем _max_locks_per_transaction_: важно лишь, чтобы общее число блокировок в системе не превысило установленный предел. Пул создается при запуске, так что изменение любого из двух указанных параметров требует перезагрузки сервера.  
  
Все блокировки можно посмотреть в представлении pg_locks.

Возможна ситуация _взаимоблокировки_ или _тупика_ (deadlock), при которой одной транзакции для продолжения работы требуется ресурс, занятый второй транзакцией, а второй необходим ресурс, занятый первой (в общем случае может произойти взаимоблокировка и более двух транзакций). В таком случае ожидание будет продолжаться бесконечно, поэтому PostgreSQL автоматически определяет такие ситуации и аварийно прерывает одну из транзакций, чтобы остальные могли продолжить работу.

| режим блокировки       | AS  | RS  | RE  | SUE | S   | SRE | E   | AE  | пример SQL-команд                                                        |
| ---------------------- | --- | --- | --- | --- | --- | --- | --- | --- | ------------------------------------------------------------------------ |
| Access Share           |     |     |     |     |     |     |     | X   | SELECT                                                                   |
| Row Share              |     |     |     |     |     |     | X   | X   | SELECT FOR UPDATE/SHARE                                                  |
| Row Exclusive          |     |     |     |     | X   | X   | X   | X   | INSERT, UPDATE, DELETE                                                   |
| Share Update Exclusive |     |     |     | X   | X   | X   | X   | X   | VACUUM, ALTER TABLE*, СREATE INDEX CONCURRENTLY                          |
| Share                  |     |     | X   | X   |     | X   | X   | X   | CREATE INDEX                                                             |
| Share Row Exclusive    |     |     | X   | X   | X   | X   | X   | X   | CREATE TRIGGER, ALTER TABLE*                                             |
| Exclusive              |     | X   | X   | X   | X   | X   | X   | X   | REFRESH MAT. VIEW CONCURRENTLY                                           |
| Access Exclusive       | X   | X   | X   | X   | X   | X   | X   | X   | DROP, TRUNCATE, VACUUM FULL, LOCK TABLE, ALTER TABLE*, REFRESH MAT. VIEW |

|режим|FOR KEY SHARE|FOR SHARE|FOR NO KEY UPDATE|FOR UPDATE|
|---|---|---|---|---|
|FOR KEY SHARE||||Х|
|FOR SHARE|||Х|Х|
|FOR NO KEY UPDATE||Х|Х|Х|
|FOR UPDATE|Х|Х|Х|Х|


# Режимы блокировок в PostgreSQL

## Общие блокировки

1. **Access Share**
   - **Описание**: Самый слабый режим блокировки.
   - **Использование**: Применяется для обычных операций чтения, таких как `SELECT`.
   - **Пример**:
     ```sql
     SELECT * FROM my_table;
     ```

2. **Row Share**
   - **Описание**: Блокировка уровня строки.
   - **Использование**: Используется для `SELECT FOR UPDATE` или `SELECT FOR SHARE`.
   - **Пример**:
     ```sql
     SELECT * FROM my_table FOR UPDATE;
     ```

3. **Row Exclusive**
   - **Описание**: Блокировка для операций, изменяющих строки.
   - **Использование**: Применяется для `INSERT`, `UPDATE`, `DELETE`.
   - **Пример**:
     ```sql
     INSERT INTO my_table (column1) VALUES ('value');
     ```

4. **Share Update Exclusive**
   - **Описание**: Блокировка для операций обновления таблицы без изменения данных.
   - **Использование**: Применяется для `VACUUM`, `ANALYZE`, `ALTER TABLE`.
   - **Пример**:
     ```sql
     VACUUM my_table;
     ```

5. **Share**
   - **Описание**: Блокировка для операций создания индексов.
   - **Использование**: Применяется для `CREATE INDEX`.
   - **Пример**:
     ```sql
     CREATE INDEX my_index ON my_table (column1);
     ```

6. **Share Row Exclusive**
   - **Описание**: Блокировка для операций, изменяющих структуру таблицы и триггеры.
   - **Использование**: Применяется для `CREATE TRIGGER`, `ALTER TABLE`.
   - **Пример**:
     ```sql
     CREATE TRIGGER my_trigger BEFORE INSERT ON my_table FOR EACH ROW EXECUTE FUNCTION my_function();
     ```

7. **Exclusive**
   - **Описание**: Блокировка для операций, изменяющих материализованные представления.
   - **Использование**: Применяется для `REFRESH MATERIALIZED VIEW CONCURRENTLY`.
   - **Пример**:
     ```sql
     REFRESH MATERIALIZED VIEW CONCURRENTLY my_matview;
     ```

8. **Access Exclusive**
   - **Описание**: Самая сильная блокировка.
   - **Использование**: Применяется для `DROP`, `TRUNCATE`, `VACUUM FULL`, `LOCK TABLE`.
   - **Пример**:
     ```sql
     DROP TABLE my_table;
     ```

## Особенности блокировок строк

1. **Исключительные блокировки**

   - **FOR UPDATE**
     - **Описание**: Полное изменение или удаление строки.
     - **Использование**: Применяется для блокировки строки перед изменением.
     - **Пример**:
       ```sql
       SELECT * FROM my_table WHERE id = 1 FOR UPDATE;
       ```

   - **FOR NO KEY UPDATE**
     - **Описание**: Изменение только неключевых полей.
     - **Использование**: Применяется для блокировки строки перед изменением неключевых полей.
     - **Пример**:
       ```sql
       SELECT * FROM my_table WHERE id = 1 FOR NO KEY UPDATE;
       ```

2. **Разделяемые блокировки**

   - **FOR SHARE**
     - **Описание**: Блокирует строку для чтения, не позволяя изменения другими транзакциями.
     - **Использование**: Применяется для гарантии неизменности строки на время чтения.
     - **Пример**:
       ```sql
       SELECT * FROM my_table WHERE id = 1 FOR SHARE;
       ```

   - **FOR KEY SHARE**
     - **Описание**: Допускает изменение неключевых полей.
     - **Использование**: Применяется для проверки внешних ключей.
     - **Пример**:
       ```sql
       SELECT * FROM my_table WHERE id = 1 FOR KEY SHARE;
       ```

3. **Мультитранзакции (MultiXact)**
   - **Описание**: Группа транзакций, удерживающих разделяемую блокировку строки.
   - **Использование**: Используется в ситуациях, когда несколько транзакций должны удерживать блокировку одновременно.
   - **Пример**:
     ```sql
     BEGIN;
     SELECT * FROM my_table WHERE id = 1 FOR SHARE;
     -- в другой транзакции
     BEGIN;
     SELECT * FROM my_table WHERE id = 1 FOR SHARE;


