# PostgreSQL

## Общее

**OLTP** системы предназначены для обработки большого количества кратковременных транзакций в реальном времени. Они широко используются в операционных системах, таких как системы управления заказами, банковские системы, системы бронирования и т.д.

- PostgreSQL
- MySQL

**OLAP** системы предназначены для выполнения сложных аналитических запросов, которые обычно используются для поддержки принятия решений в бизнесе. Они применяются в системах бизнес-аналитики, отчетности и анализа данных.

- Oracle OLAP
- Tableau

### Relations

Отношения – это по фатку любые объекты в PG:
- Tables
- Indexes
- View
- Materialised View
- Sequence

#### VIEW vs MATERIALIZED

- VIEW не хранит данные в себе
-  MATERIAZILZED её кэширует

## MVCC

Multiversion concurrency control

- Есть два вида БД: те, что блокируются и версионируются
- Каждая транзакция характеризуется некоторым id-шником. Id-шники транзакций монотонно растут. У любой строчки есть 2 атрибута, которые представляют метаинформацию для обеспечения механизма: updated_by_id — id-шник транзакции, которая последней осуществила обновление этой записи и deleted_by_id — id-шник транзакции, которая удалила данную запись.

| Преимуещества                              | Недостатки                 |
| ------------------------------------------ | -------------------------- |
| Параллелизм (с помощью изоляции снэпшотом) | Раздувание и сборка мусора |
| Нет блокировок                             |                            |

## MVCC Advanced

### Слои (forks) и файлы

Каждому отношению соответствует несколько _слоев_ (forks). Слои бывают нескольких типов и каждый из них содержит определенный вид данных.

Если слой есть, то вначале он представлен одним-единственным _файлом_. Имя файла состоит из числового идентификатора, к которому может быть добавлено окончание, соответствующее имени слоя.  
  
Файл постепенно растет и, когда его размер доходит до 1 ГБ, создается следующий файл этого же слоя (такие файлы иногда называют _сегментами_). Порядковый номер сегмента добавляется в конец имени файла.

Файлы, в свою очередь, разделены на _страницы_ (или _блоки_), обычно по 8 КБ.

![forks-postgresql](forks_postgresql.png)


### Страницы

### Версии строк


## Уровни изоляции

**"Грязное" чтение**: Транзакция читает данные, записанные параллельной незавершённой транзакцией.

**Неповторяемое чтение**: Транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изменены другой транзакцией (которая завершилась после первого чтения).

**Фантомное чтение**: Транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия, и обнаруживает, что набор строк, удовлетворяющих условию, изменился из-за транзакции, завершившейся за это время.

**Аномалия сериализации**: Когда невозможно предсказать в каком порядке выполнятся транзакции. Важно, когда берем проценты от числа.

- 1000 * 110% + 1000 = 2100
- (1000 + 1000) * 110% = 2200
## Индексы

### Общее

#### Уникальные индексы

```sql
CREATE UNIQUE INDEX
```

Будет хранить значения только уникальные.

#### Индексы на основе выражений

```sql
CREATE UNIQUE INDEX aircrafts_unique_model_key
  ON aircrafts ( lower( model ) );
```

#### Частичные индексы

```sql
CREATE INDEX bookings_book_date_part_key
  ON bookings ( book_date )
  WHERE total_amount > 1000000;
```

Частичные индексы выглядят очень привлекательно, но в большинстве случаев их преимущества по сравнению с обычными индексами будут минимальными. Однако размер частичного индекса будет меньше, чем размер обычного.

### B-Tree 

1. сбалансированное дерево — это древовидная структура данных, в которой узлы отсортированы и сбалансированы таким образом, чтобы все пути от корня до листьев имели одинаковую длину. В каждом узле хранятся ключи и указатели на дочерние узлы.
2. При вставке нового ключа дерево автоматически перестраивается, чтобы сохранять балансировку. То же самое происходит при удалении ключа. Это обеспечивает эффективность операций поиска, вставки и удаления.
3. Поиск в B-Tree осуществляется за логарифмическое время (O(log n)), так как на каждом уровне дерева осуществляется бинарный поиск среди ключей.

### Hash

1. Каждое значение столбца преобразуется хэш-функцией в уникальный хэш-код, который указывает на позицию записи в хэш-таблице.
2. Hash индексы **подходят** только для точного поиска (например, `WHERE column = value`). Они **неэффективны** для диапазонных запросов и не поддерживают сортировку.

### GiST (Generalized Search Tree)

GiST индексы предоставляют общую инфраструктуру для реализации различных типов индексов.

1. **Структура**: GiST индексы имеют древовидную структуру, похожую на B-Tree, но более гибкую.
2. **Использование**: GiST используется для создания индексов для нестандартных типов данных, таких как геометрические и полнотекстовые данные.

### GIN (Generalized Inverted Index)

GIN индексы используются в основном для индексирования массивов и полнотекстового поиска.

1. **Структура**: GIN индексы содержат инвертированные списки, где каждому элементу (например, слову в тексте) соответствует список документов (строк), содержащих этот элемент.
2. **Применение**: Эти индексы особенно полезны для поиска по ключевым словам и тегам.

### BRIN (Block Range INdexes) 

BRIN индексы предназначены для работы с очень большими таблицами, где данные имеют физическую упорядоченность.

1. **Структура**: BRIN индексы хранят метаданные о блоках таблицы, например, минимальное и максимальное значение в блоке.
2. **Эффективность**: Они очень компактны и обеспечивают эффективный доступ к данным при условии, что данные имеют определённый порядок.

## INCLUDE INDEX

`INCLUDE`позволяет создавать ***покрывающие*** индексы, которые значительно ускоряют выполнение запросов, снижая необходимость обращения к данным в таблице.

## Селективность

Индексы более полезны, когда из таблицы выбирается лишь небольшая доля строк, т. е. при *высокой селективности выборки*.

### Как мерить селективность?

$Селективность = Общее количество строк в таблице / Количество подходящих строк​$

### Что такое селективность?

Селективность в контексте баз данных и запросов к ним — это мера того, какая доля строк из таблицы удовлетворяет определенному условию запроса. Она играет ключевую роль в выборе оптимизатором запросов наилучшего плана выполнения. Высокая селективность означает, что условие запроса фильтрует большую часть строк (например, выборка одной или нескольких строк из миллиона), тогда как низкая селективность означает, что условие запроса возвращает значительную часть таблицы (например, половину строк).

### Как измеряется селективность?

Селективность измеряется как отношение числа строк, удовлетворяющих условию, к общему числу строк в таблице. Это можно выразить следующей формулой:

$\text{Селективность} = \frac{\text{Количество подходящих строк}}{\text{Общее количество строк в таблице}}$

**Пример 1: Высокая селективность**

   ```sql
   SELECT * FROM users WHERE user_id = 12345;
   ```

   $\text{Селективность} = \frac{1}{1,000,000} = 0.000001$


**Пример 2: Низкая селективность**

   ```sql
   SELECT * FROM users WHERE country = 'USA';
   ```

   $\text{Селективность} = \frac{500,000}{1,000,000} = 0.5$

### Как выбирать индексы?

### Как грамотно создавать индексы?

## Что делать когда индексы разрослись?

### VACUUM
	
- Простая команда `VACUUM` (без `FULL`) только высвобождает пространство для текущей таблице. Не требует исключительной блокировки.
- `VACUUM FULL` переписывает всё содержимое таблицы в новый файл на диске, что позволяет возвратить неиспользованное пространство операционной системе. Эта форма работает намного медленнее и запрашивает исключительную блокировку для каждой обрабатываемой таблицы.
### CLUSTER

Процесс кластеризации перестраивает таблицу так, чтобы строки хранились в порядке, соответствующем порядку ключей индекса. 

```sql
CLUSTER my_table USING my_index;
```

### REINDEX

`REINDEX` перестраивает индекс, обрабатывая данные таблицы, к которой относится индекс, и в результате заменяет старую копию индекса. Блокирующий, но есть настрйока неблокирующая.

```sql
REINDEX INDEX CONCURRENTLY indexname1;
```
### pg_repack

[pg_repack](https://github.com/reorg/pg_repack) – расширение, которое пересобирает таблицы и индексы.  Не блокирующий!


## Explain

```sql
EXPLAIN SELECT * FROM users WHERE user_id = 12345;
```

```plaintext
Index Scan using idx_user_id on users  (cost=0.29..8.30 rows=1 width=52)
  Index Cond: (user_id = 12345)
```


1. Тип операции (Index Scan)
2. Используемый индекс (using idx_user_id)
3. Затраты (cost=0.29..8.30)
   - Startup Cost (0.29): Затраты на инициализацию операции (например, на поиск первой подходящей строки).
   - Total Cost (8.30): Общие затраты на выполнение всей операции до её завершения.
4. Количество строк (rows=1) – Оценка количества строк, которые будут возвращены этой операцией.
5. Ширина (width=52) – Средний размер строки в байтах, возвращаемой этой операцией.
6. Условие индекса (Index Cond: (user_id = 12345)) – Условие, применяемое к индексу для фильтрации строк.


## Моргунов [10.1-10.5]

### Методы доступа

Метод доступа характеризует тот способ, который используется для просмотра таблиц и извлечения только тех строк, которые соответствуют критерию отбора

#### Sequential Scan

Поиск по всей таблице по каждой строке.

Последовательное сканирование — самый эффективный способ прочитать всю таблицу или значительную ее часть. Иными словами, последовательное сканирование хорошо работает при низкой селективности. (При высокой селективности, когда из всей таблицы нужна только небольшая часть строк, более предпочтительным будет использование индекса.)

##### Когда:

- Нет подходящего индекса для использования.
- Запрос затрагивает большую часть таблицы (например, возвращает более 30-50% строк), и использование индекса не даст существенного выигрыша, то есть низкая селективность
- Таблица мала, и затраты на построение индекса не оправданы.

#### Index Scan

Поиск по индексу.
##### Когда:

- Есть индекс, подходящий для условий запроса.
- Запрос возвращает небольшое количество строк, то есть высокая селективность.
- Требуется быстро найти строки по значению одного или нескольких столбцов.

>[!cite]
>В таком случае при низкой селективности выборки, т. е. когда из таблицы отбирается значительное число строк, использование индексного поиска может не только не давать ускорения работы, но даже и снижать производительность.

#### Index only scan

Похоже на обычное сканирование индекса, но без обращения к самой таблице. Используется, когда все данные для запроса содержатся в индексе.

>[!cite]
>Все индексы в Postgres Pro являются _вторичными_, что значит, что каждый индекс хранится вне области основных данных таблицы (_куча_ таблицы).
>
>Это значит, что при обычном сканировании индекса для извлечения каждой строки необходимо прочитать данные <u>и из индекса, и из кучи</u>. Более того, тогда как элементы индекса, соответствующие заданному условию `WHERE`, обычно находятся в индексе рядом, строки таблицы могут располагаться в куче произвольным образом. Таким образом, обращение к куче при поиске по индексу влечёт множество операций произвольного чтения кучи, которые могут обойтись недёшево, особенно на традиционных вращающихся носителях
>
>Чтобы решить эту проблему с производительностью, Postgres Pro поддерживает _сканирование только индекса_, при котором результат запроса может быть получен из самого индекса, без обращения к куче.

##### Когда

- Индекс покрывает все столбцы, необходимые для запроса.

#### Bitmap scan

Этот метод объединяет использование индексов и последовательное сканирование. Создаётся *битовая карта*, указывающая на нужные страницы таблицы, которые затем считываются последовательно.

>[!cite]
>Является модификацией просмотра на основе индекса. Данный метод позволяет оптимизировать индексный по- иск за счет того, что сначала производится поиск в индексе для всех искомых строк и формирование так называемой битовой карты, в которой указывается, в каких страницах таблицы эти строки содержатся. После того как битовая карта сформирована, выполняется извлечение строк из страниц таблицы, но при этом обращение к каждой странице производится только один раз.

##### Когда:

- Запрос затрагивает больше строк, чем это эффективно для обычного сканирования индекса, но меньше, чем требуется для последовательного сканирования.

### JOIN-ы строк

#### Nested loop

Для каждой строки из первой (внешней) таблицы выполняется цикл поиска соответствующих строк во второй (внутренней) таблице.

- Когда одна из таблиц очень мала.
- Когда используется индекс для доступа к строкам второй таблицы.

#### Hashing

Строится хеш-таблица на основе строк одной таблицы (внутренней), а затем для каждой строки из другой таблицы (внешней) производится поиск соответствующих строк в хеш-таблице.

**Когда используется**:

- Когда нет индексов на ключ соединения.
- Когда одна из таблиц достаточно мала, чтобы поместиться в памяти.

>[!cite]
При соединении хешированием строки одного набора помещаются в хеш-таблицу, содержащуюся в памяти, а строки из второго набора перебираются, и для каждой из них проверяется наличие соответствующих строк в хеш-таблице. Ключом хеш-таблицы является тот столбец, по которому выполняется соединение наборов строк. Как правило, число строк в том наборе, на основе которого строится хеш-таблица, меньше, чем во втором наборе. Это позволяет уменьшить ее размер и ускорить процесс обращения к ней. Данный метод работает только при выполнении эквисоедине- ний, поскольку для хеш-таблицы имеет смысл только проверка на равенство прове- ряемого значения одному из ее ключей. Метод эффективен для больших выборок.

#### Merge

Обе таблицы предварительно сортируются по ключу соединения, а затем производится линейное сканирование и объединение строк на основе ключа.

**Когда используется**:

- Когда обе таблицы отсортированы по ключу соединения.
- Когда сортировка ключей менее затратна, чем другие методы соединения.

>[!cite]
Соединение методом слияния производится аналогично сортировке слиянием. В этом случае оба набора строк должны быть предварительно отсортированы по тем столбцам, по которым производится соединение. Затем параллельно читаются строки из обоих наборов и сравниваются значения столбцов, по которым производится соединение. При совпадении значений формируется результирующая строка. Этот процесс продолжается до исчерпания строк в обоих наборах. Этот метод, как и ме- тод соединения хешированием, работает только при выполнении эквисоединений. Он пригоден для работы с большими наборами строк.

### Query Planner

Структура плана запроса представляет собой дерево, состоящее из так называемых узлов плана (plan nodes).

### Управление планировщиком

```sql
SET enable_nestloop = off;
SET enable_mergejoin = off;
SET enable_hashjoin = off;
```

Можно принудительно выбирать другой алгоритм соединения для выполнения запросов
### Оптимизация запросов

- обновление статистики, на основе которой планировщик строит планы;
- изменение исходного кода запроса;
- изменение схемы данных, связанное с денормализацией: создание материализо- ванных представлений и временных таблиц, создание индексов, использование вычисляемых столбцов таблиц;
- изменение параметров планировщика, управляющих выбором порядка соедине- ния наборов строк: использование общих табличных выражений (запросы с пред- ложением `WITH`), использование фиксированного порядка соединения (параметр `join_collapse_limit` = 1), запрет раскрытия подзапросов и преобразования их в соединения таблиц (параметр `from_collapse_limit` = 1);
- изменение параметров планировщика, управляющих выбором метода доступа к данным (`enable_seqscan`, `enable_indexscan`, `enable_indexonlyscan`, `enable_bitmapscan`) и способа соединения наборов строк (`enable_nestloop`, `enable_hashjoin`, `enable_mergejoin`);
- изменение параметров планировщика, управляющих использованием ряда операций: агрегирование на основе хеширования (`enable_hashagg`), материализация временных наборов строк (`enable_material`), выполнение явной сортиров- ки при наличии других возможностей (`enable_sort`).

>[!todo]
>В конце решить контрольные вопросы

