# C++ Interview

- Diamond problem, как решить?
	- порядок инициализации, полей и классов
- Как реализовать базовые структуры данных? Как реализовать базовые алгоритмы?
- Научиться решать базовые алго вопросы
- ОС:
	- Режим ядра пользователя
	- M Process commincation
	- Виртуальная память
	- User kernel mode
	- System calls
	- Context switching
	- IPC
	- Planning
- Архитектура компьютера
	- Пайплайн внутри процессора
	- Пайп фетчинг
	- Зачем нужны кэши внутри процессора?
	- Тракт данных
	- Оптимизации
	- Прерывания
- Шины
- DMA
- Компьютерные сети
	- протоколы и их иерхархия
	- ARP / IP / ICMP
	- DNS / HTTP / FTP / SSH
	- tcp/ip и каждый уровень стэка
	- транспорный и прикалдной стэк
	- 
- STL:
	- smart pointers and other pointers
	- multithreading
	- как перевыделяется память при расширении в векторе? в листе? 
	- сравнение структур данных по комплексити и по тому стоят ли там элементы рядом
- что нужно чтобы класс можно было засунуть в мапу? что должно быть определено?
- ООП
	- Виды полиморфизма, статический и динамический
	- inheritance private, public, protected разница
- почему в деструктуоре нельзя бростаь exception? расркутка стека
- конструктор по умолчанию
- правило 3-х или 5-ти
- POD типы
- MT base optimization
- виртуальный методы, pure virtual
- как защитить класс от копирования?
- extern
- union

explicit слово зачем нужно
этапы сборки
макросы
защита хедеров от повторного включения
что будет если вызвать оператор delete на nullptr
а delete на 0
виртуальные деструкторы
move-семантика
как запретить наследоваться от класса
реализация паттернов например singleton

SFINAE
vector vs list
ADL

iterators виды
пордяок конструирования и разрушения объектов
зачем нужен виртуальный деструктор и виртуальное наследование
vfptr
pure virtual call

throw exceptions в деструкторе и конструкторе
гарантии безопасности исключений

types of pointers, shared, unique, smart, weak_ptr (and what problem it solves)
vector vs array
how much memory is allocated on the stack?
what returns size_of?
how big is a pointer?
how does a memory stores in a vector?
how does a memory stores in a list?
how does free knows how many bytes to relinquish?
how tcp connection is established?
how many ways in handshake in tcp?
smallest addresable unit in memory in OS
what is `new` do? two things
placement new?
how big long int? other types? make a table
signed vs unsigned int
what is array?
How large is a struct with no data members and a single method taking in an integer an returning void?



### RAII

Resource Acquisition Is Initialization

В C++ управление ресурсами, такими как динамическая память или открытые файлы, может быть источником множества проблем, таких как утечки памяти, неопределенное поведение и непредсказуемые ошибки. RAII призван решить эти проблемы, предоставляя надежный и безопасный механизм управления ресурсами.

Проблемы, которые RAII решает:

1. **Утечки памяти**: Без RAII разработчику приходится вручную отслеживать и освобождать выделенную память. Забытая операция освобождения памяти может привести к утечкам. RAII гарантирует, что память будет автоматически освобождена при уничтожении объекта.
    
2. **Неопределенное поведение**: Если ресурсы не управляются должным образом, это может привести к неопределенному поведению программы. RAII гарантирует, что ресурсы всегда находятся в определенном состоянии.
    
3. **Исключения и безопасность**: RAII позволяет обрабатывать исключения более элегантно и безопасно. Ресурсы будут автоматически освобождены даже в случае возникновения исключительных ситуаций.


### Зачем нужен виртуальный деструктор?

Чтобы избежать возможной утечки ресурсов или другого неконтролируемого поведения объекта, в логику работы которого включен вызов деструктора.

### Для каких целей применяется ключевое слово **const**?

**Ответ:**  

1. Позволяет задать константность объекта
2. Позволяет задать константность указателя
3. Позволяет указать, что данный метод не модифицирует члены класса, т.е. сохраняет состояние объекта

### Как защитить объект от копирования?

Сделать **private** конструктор копирования и оператор **=**.

### В чем разница между **struct** и **class**?

### - LockFree containers and thinking pattern

- Knowledge of networks and interaction protocols.
- Experience with handling large volumes of incoming data.
- Multithreading programming, understanding of CPU memory models.


## [WIP] Различия версий С++

### **C++17**

- **Structured Bindings** Позволяют напрямую присваивать несколько возвращаемых значений переменным.
  
    ```cpp
    auto [a, b] = std::make_pair(1, 2);
    ```
  
  - **if constexpr**: Условная компиляция на основе аргументов шаблона.

    ```cpp
    template <typename T>
    void foo(T x) {
        if constexpr (std::is_integral_v<T>)
            std::cout << "Integral\n";
        else
            std::cout << "Non-Integral\n";
    }
    ```

  - **`std::optional`, `std::variant`, `std::any`:** Новые инструменты для работы с необязательными значениями, вариантами и универсальными контейнерами.
  -  `std::filesystem` для работы с путями и директориями.
  - **Параллельные алгоритмы**?????

### **C++20**

- **Главные особенности:**
  - **Concepts (Концепции):** Упрощают ограничения для шаблонов, улучшая читаемость и сообщения об ошибках.

    ```cpp
    template<typename T>
    concept Integral = std::is_integral_v<T>;

    template<Integral T>
    T add(T a, T b) {
        return a + b;
    }
    ```

  - **Ranges (Диапазоны):** Новая библиотека для работы с последовательностями, которая упрощает применение алгоритмов.

    ```cpp
    std::vector<int> v = {1, 2, 3, 4};
    auto res = v | std::views::transform([](int x) { return x * 2; });
    ```

  - **Coroutines (Корутины):** Поддержка асинхронного программирования на основе корутин.

    ```cpp
    std::future<int> async_add(int a, int b) {
        co_return a + b;
    }
    ```

  - **Modules (Модули):** Упрощают разбиение крупных проектов на части, улучшая время компиляции и модульность.
  - **Расширенные возможности `constexpr`:** Теперь больше операций можно выполнять на этапе компиляции.

### **C++23**

- **Новое:**
  - **Deduction for `this`**: Член-функции могут использовать `this` как неявный параметр, упрощая синтаксис.
  
    ```cpp
    struct S {
        void foo(this S& self) {
            std::cout << "Self reference\n";
        }
    };
    ```

  - **`std::flat_map` и `std::flat_set`:** Новые структуры данных для кэш-дружественных контейнеров.
  - **Multidimensional subscript operator**: Упрощает доступ к многомерным массивам.

    ```cpp
    int arr[3][4];
    arr[1, 2] = 5; // Пример с многомерным доступом
    ```

  - **Расширенная поддержка constexpr**: Теперь еще больше операций доступно для выполнения на этапе компиляции.

### **C++26** (Предполагаемые особенности)

- **Ожидаемые нововведения:**
  - **Метаклассы (Metaclasses):** Новая концепция для генерации и настройки типов, что поможет при работе с крупными кодовыми базами.
  - **Статическая рефлексия (Static Reflection):** Позволит изучать код во время компиляции, что облегчит генерацию и оптимизацию кода.
  - **Контракты (Contracts):** Возможность задать предусловия, постусловия и инварианты для функций.

    ```cpp
    int divide(int a, int b) [[expects: b != 0]] {
        return a / b;
    }
    ```

- **Предложения:**
  - **Pattern matching (Сопоставление с образцом):** Введение мощного синтаксиса сопоставления, похожего на другие современные языки, такие как Rust и Swift.
  - **Фреймворк исполнителей (Executor Framework):** Для лучшего управления асинхронными задачами и пулами потоков.

### Заключение
Каждая версия C++ добавляет новые возможности для улучшения производительности, расширения возможностей параллельного программирования и удобства работы с шаблонами.