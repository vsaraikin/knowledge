# Celery & Message Queues

## Celery

**Celery** — **это** программа, которая отслеживает **задачи** (tasks), которые необходимо выполнить, и в которой есть набор **обработчиков** (workers), которые будут выполнять эти задачи. Основной смысл в том, что она (программа) может выполнять несколько задач **параллельно** и что она **не блокирует** поставщиков (producers) этих самых задач.

### Best practices

1. Don't use the database as your AMQP Broker
2. Use more Queues (ie. not just the default one)
3. Use priority workers
4. Use Celery's error handling mechanisms
5. Use Flower - for monitoring
6. Keep track of results only if you really need them
7. Don't pass Database/ORM objects to tasks

After giving this talk at a local Python meetup a few people suggested I add this to the list. What's it all about? You shouldn't pass Database objects (for instance your User model) to a background task because the serialized object might contain stale data. What you want to do is feed the task the User id and have the task ask the database for a fresh User object.

### Celery beat

**Celery beat -** a **scheduler;** it **kick** off tasks at regular intervals, that are then executed by available worker nodes in the cluster.

### Что будет, если celery worker упал, но не доделал task

Использовать Task Retry Decorator.

### Приоритеты в celery

## Message brokers

### MQ и MB

Брокеры сообщений используют очереди сообщений, чтобы передавать информацию. То есть MQ – это струтура данных, которая хранит что-то, а брокер – это софтина, которая управляет этим.

### Что такое MQ

Очереди сообщений, по существу, являются связующим звеном между различными процессами в ваших приложениях и обеспечивают надежный и масштабируемый интерфейс взаимодействия с другими подключенными системами и устройствами. О́чередь — структура данных с дисциплиной доступа к элементам «первый пришёл — первый вышел». Добавление элемента возможно лишь в конец очереди, выборка — только из начала очереди, при этом выбранный элемент из очереди удаляется.

Десять причин, почему очереди сообщений являются жизненно важным компонентом для любой архитектуры или приложения:

- *Слабое связывание* — очереди сообщений создают неявные интерфейсы обмена данными, которые позволяют процессам быть независимыми друг от друга т.е вы просто определяете формат сообщений отправляемых от одного процесса другому.
- *Избыточность* — Очереди позволяют избежать случаев неэкономного использования ресурсов процесса(например памяти) в результате хранения необработанной (лишней) информации.
- *Масштабируемость* — очереди сообщений позволяют распределить процессы обработки информации. Таким образом, они позволяют легко наращивать скорость, с которой сообщения добавляются в очередь и обрабатываются.
- *Эластичность и возможность выдерживать пиковые нагрузки* — очереди сообщений могут выполнять роль своего рода буфера для накопления данных в случае пиковой нагрузки, смягчая тем самым нагрузку на систему обработки информации и не допуская ее отказа.
- *Отказоустойчивость* — очереди сообщений позволяют отделить процессы друг от друга, так что если процесс, который обрабатывает сообщения из очереди падает, то сообщения могут быть добавлены в очередь на обработку позднее, когда система восстановится.
- *Гарантированная доставка* — использование очереди сообщений гарантирует, что сообщение будет доставлено и обработано в любом случае (пока есть хотя бы один обработчик).
- *Гарантированный порядок доставки* — большая часть систем очередей сообщений способны обеспечить гарантии того, что данные будут обрабатываться в определённом порядке (чаще всего в том порядке в котором они поступили).
- *Буферизация* — очереди сообщений позволяет отправлять и получать сообщения при этом работая с максимальной эффективностью, предлагая буферный слой — процесс записи в очередь может происходить настолько быстро, насколько быстро это в состоянии выполнить очередь сообщений, а не обработчик сообщения.
- *Понимание потоков данных* — очереди сообщений позволяют выявлять узкие места в потоках данных приложения, легко можно определить какая из очередей забивается, какая простаивает и определить что необходимо делать — добавлять новых обработчиков сообщений или оптимизировать текущую архитектуру.
- *Асинхронная связь* — очереди сообщений предоставляют возможность асинхронной обработки данных, которая позволяет поместить сообщение в очередь без обработки, позволяя системе обработать сообщение позднее, когда появится возможность.

### Брокеры сообщений

Брокер сообщений представляет собой тип построения архитектуры, при котором элементы системы «общаются» друг с другом с помощью посредника. Благодаря его работе происходит снятие нагрузки с веб-сервисов, так как им не приходится заниматься пересылкой сообщений: всю сопутствующую этому процессу работу он берёт на себя.

| Преимущества                                                                                                                                                                                                                                                             | Недостатки                                                                                                                                                                |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Для организации связи между отдельными службами, даже если какая-то из них не работает в данный момент. То есть продюсер может отправлять сообщения, несмотря на то, проявляет ли активность потребитель в настоящее время..                                             | Тяжелее ловить. Из-за асинхронной работы всей системы, а также её распределённого характера могут возникать ошибки, выяснение сути которых может стать непростой задачей. |
| За счёт асинхронной обработки задач можно увеличить производительность системы в целом.                                                                                                                                                                                  |                                                                                                                                                                           |
| Для обеспечения надёжности доставки сообщений: как правило, брокеры обеспечивают механизмы многократной отправки сообщений в тот же момент или через определённое время. Кроме того, обеспечивается соответствующая маршрутизация сообщений, которые не были доставлены. |                                                                                                                                                                           |

**Когда брокеры сообщений могут быть полезны:**

- Если в рамках вашей системы есть действия, которые требуют для своего выполнения много времени и потребляют много ресурсов, при этом они не требуют немедленного результата.
- Микросервисы: если ваша система достаточно сложна и состоит из отдельных сервисов, то для их координации можно использовать брокер сообщений, который в этом случае будет выступать в роли как бы центрального роутера. Каждый сервис подписывается только на свой тип сообщений, выстраивается определённая логика их обработки.
- Мобильные приложения: здесь возможен вариант с задействованием push-уведомлений, когда множество смартфонов с установленным приложением подписаны на определённую тему. Если в ней публикуется какая-либо новость, то подписанный смартфон выводит уведомление.

### RabbitMQ

- producers
- exchanges (how messages are routed—provide a great deal of flexibility)
- queues
- consumers

A producer pushes messages to an exchange, which then routes messages to queues (or other exchanges). A consumer then continues to read messages from the queue, often up to a predetermined limit of messages.

Producers add data to the tail of the queue; consumers receive data from the head of the queue. The queues are “first in, first out” with RabbitMQ: the first message in the queue is consumed first.

### Kafka

- producers
- consumers
- clusters
- brokers
- topics (stream of data comprising individual records, like a folder in a file system)
- partitions

Producers send records to clusters, which store those records and then pass them to consumers. Each server node in the cluster is a “broker,” which stores the data provided by the producer until it is read by the consumer.

>Пишет на диск, поэтому безопаснее. Все сохраняет.

### RabbitMQ vs Kafka – когда что выбирать?

RabbitMQ:

– complex routing for microservieces

Kafka:

– activity tracking (e.g from website)
– stream processing
– event sourcing (stores a sequence of events)

Если вам нужно перекидывать сообщения между сервисами в небольшом количестве — ваш выбор однозначно **RabbitMQ**. Если вам необходимо быстро сохранять кучу событий — метрики от клиентов, логи, аналитика и тд — ваш выбор **kafka**.

### Гарантии доставки в Kafka vs RabbitMQ

**Гарантии доставки в RabbitMQ**

- надежностью сообщений — они не пропадут, пока хранятся на RabbitMQ;
- уведомлениями о сообщениях — RabbitMQ обменивается сигналами с отправителями и получателями.

**Гарантии доставки в Kafka**

- долговечностью сообщений — сообщения, сохранённые в сегменте, не теряются;
- Уведомлениями о сообщениях — обмен сигналами между Kafka (и, возможно, хранилищем Apache Zookeeper) с одной стороны и источником/получателем — с другой.

*References:*

[Apache Kafka и RabbitMQ: семантика и гарантия доставки сообщений](https://habr.com/ru/company/itsumma/blog/437446/)
[RabbitMQ против Kafka: два разных подхода к обмену сообщениями](https://habr.com/ru/company/itsumma/blog/416629/)
[Kafka VS RabbitMQ](https://medium.com/@vozerov/kafka-vs-rabbitmq-38e221cf511b)