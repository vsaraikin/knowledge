#  Message Brokers

## MQ и MB

Брокеры сообщений используют очереди сообщений, чтобы передавать информацию. То есть MQ – это струтура данных, которая хранит что-то, а брокер – это софтина, которая управляет этим.

## Что такое MQ

Очереди сообщений, по существу, являются связующим звеном между различными процессами в ваших приложениях и обеспечивают надежный и масштабируемый интерфейс взаимодействия с другими подключенными системами и устройствами. О́чередь — структура данных с дисциплиной доступа к элементам «первый пришёл — первый вышел». Добавление элемента возможно лишь в конец очереди, выборка — только из начала очереди, при этом выбранный элемент из очереди удаляется.

Десять причин, почему очереди сообщений являются жизненно важным компонентом для любой архитектуры или приложения:

- *Слабое связывание* — очереди сообщений создают неявные интерфейсы обмена данными, которые позволяют процессам быть независимыми друг от друга т.е вы просто определяете формат сообщений отправляемых от одного процесса другому.
- *Избыточность* — Очереди позволяют избежать случаев неэкономного использования ресурсов процесса(например памяти) в результате хранения необработанной (лишней) информации.
- *Масштабируемость* — очереди сообщений позволяют распределить процессы обработки информации. Таким образом, они позволяют легко наращивать скорость, с которой сообщения добавляются в очередь и обрабатываются.
- *Эластичность и возможность выдерживать пиковые нагрузки* — очереди сообщений могут выполнять роль своего рода буфера для накопления данных в случае пиковой нагрузки, смягчая тем самым нагрузку на систему обработки информации и не допуская ее отказа.
- *Отказоустойчивость* — очереди сообщений позволяют отделить процессы друг от друга, так что если процесс, который обрабатывает сообщения из очереди падает, то сообщения могут быть добавлены в очередь на обработку позднее, когда система восстановится.
- *Гарантированная доставка* — использование очереди сообщений гарантирует, что сообщение будет доставлено и обработано в любом случае (пока есть хотя бы один обработчик).
- *Гарантированный порядок доставки* — большая часть систем очередей сообщений способны обеспечить гарантии того, что данные будут обрабатываться в определённом порядке (чаще всего в том порядке в котором они поступили).
- *Буферизация* — очереди сообщений позволяет отправлять и получать сообщения при этом работая с максимальной эффективностью, предлагая буферный слой — процесс записи в очередь может происходить настолько быстро, насколько быстро это в состоянии выполнить очередь сообщений, а не обработчик сообщения.
- *Понимание потоков данных* — очереди сообщений позволяют выявлять узкие места в потоках данных приложения, легко можно определить какая из очередей забивается, какая простаивает и определить что необходимо делать — добавлять новых обработчиков сообщений или оптимизировать текущую архитектуру.
- *Асинхронная связь* — очереди сообщений предоставляют возможность асинхронной обработки данных, которая позволяет поместить сообщение в очередь без обработки, позволяя системе обработать сообщение позднее, когда появится возможность.

### Брокеры сообщений

Брокер сообщений представляет собой тип построения архитектуры, при котором элементы системы «общаются» друг с другом с помощью посредника. Благодаря его работе происходит снятие нагрузки с веб-сервисов, так как им не приходится заниматься пересылкой сообщений: всю сопутствующую этому процессу работу он берёт на себя.

| Преимущества                                                                                                                                                                                                                                                             | Недостатки                                                                                                                                                                |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Для организации связи между отдельными службами, даже если какая-то из них не работает в данный момент. То есть продюсер может отправлять сообщения, несмотря на то, проявляет ли активность потребитель в настоящее время..                                             | Тяжелее ловить. Из-за асинхронной работы всей системы, а также её распределённого характера могут возникать ошибки, выяснение сути которых может стать непростой задачей. |
| За счёт асинхронной обработки задач можно увеличить производительность системы в целом.                                                                                                                                                                                  |                                                                                                                                                                           |
| Для обеспечения надёжности доставки сообщений: как правило, брокеры обеспечивают механизмы многократной отправки сообщений в тот же момент или через определённое время. Кроме того, обеспечивается соответствующая маршрутизация сообщений, которые не были доставлены. |                                                                                                                                                                           |

**Когда брокеры сообщений могут быть полезны:**

- Если в рамках вашей системы есть действия, которые требуют для своего выполнения много времени и потребляют много ресурсов, при этом они не требуют немедленного результата.
- Микросервисы: если ваша система достаточно сложна и состоит из отдельных сервисов, то для их координации можно использовать брокер сообщений, который в этом случае будет выступать в роли как бы центрального роутера. Каждый сервис подписывается только на свой тип сообщений, выстраивается определённая логика их обработки.
- Мобильные приложения: здесь возможен вариант с задействованием push-уведомлений, когда множество смартфонов с установленным приложением подписаны на определённую тему. Если в ней публикуется какая-либо новость, то подписанный смартфон выводит уведомление.

## RabbitMQ

- producers
- exchanges (how messages are routed—provide a great deal of flexibility)
- queues
- consumers

A producer pushes messages to an exchange, which then routes messages to queues (or other exchanges). A consumer then continues to read messages from the queue, often up to a predetermined limit of messages.

Producers add data to the tail of the queue; consumers receive data from the head of the queue. The queues are “first in, first out” with RabbitMQ: the first message in the queue is consumed first.

## Kafka

- producers
- consumers
- clusters
- brokers
- topics (stream of data comprising individual records, like a folder in a file system)
- partitions

Producers send records to clusters, which store those records and then pass them to consumers. Each server node in the cluster is a “broker,” which stores the data provided by the producer until it is read by the consumer.

>Пишет на диск, поэтому безопаснее. Все сохраняет.

### Можно ли вычитывать сообщения разными консьюмерами из одной партиции?

Обычно рекомендуется иметь не более одного консьюмера из одной и той же группы консьюмеров, читающего из одной партиции. Это обеспечивает упорядоченное чтение в рамках партиции.

Технически возможно иметь несколько консьюмеров из разных групп консьюмеров, читающих из одной и той же партиции. Однако это может привести к дублированию сообщений для разных групп консьюмеров.

### Что если отправитель и получатель пишут много сообщений, попали в одну партицию?

Отправить их в отдельную партицию

### Можно ли потерять сообщение, когда его отправили в очередь?

### Exactly-Once

### Idempotency Keys

## RabbitMQ vs Kafka – когда что выбирать?

RabbitMQ:

– complex routing for microservieces

Kafka:

– activity tracking (e.g from website)
– stream processing
– event sourcing (stores a sequence of events)

Если вам нужно перекидывать сообщения между сервисами в небольшом количестве — ваш выбор однозначно **RabbitMQ**. Если вам необходимо быстро сохранять кучу событий — метрики от клиентов, логи, аналитика и тд — ваш выбор **kafka**.

### Гарантии доставки в Kafka vs RabbitMQ

**Гарантии доставки в RabbitMQ**

- надежностью сообщений — они не пропадут, пока хранятся на RabbitMQ;
- уведомлениями о сообщениях — RabbitMQ обменивается сигналами с отправителями и получателями.

**Гарантии доставки в Kafka**

- долговечностью сообщений — сообщения, сохранённые в сегменте, не теряются;
- Уведомлениями о сообщениях — обмен сигналами между Kafka (и, возможно, хранилищем Apache Zookeeper) с одной стороны и источником/получателем — с другой.

*References:*

[Apache Kafka и RabbitMQ: семантика и гарантия доставки сообщений](https://habr.com/ru/company/itsumma/blog/437446/)
[RabbitMQ против Kafka: два разных подхода к обмену сообщениями](https://habr.com/ru/company/itsumma/blog/416629/)
[Kafka VS RabbitMQ](https://medium.com/@vozerov/kafka-vs-rabbitmq-38e221cf511b)


## Паттерны

### 1. Request-Reply (Запрос-Ответ)

- **Описание**: Этот паттерн представляет собой двухстороннюю коммуникацию, где один компонент (запрашивающий) отправляет запрос, а другой (отвечающий) получает запрос и отправляет ответ обратно.
- **Применение**: Широко используется в синхронных операциях, где требуется немедленный ответ, например, в веб-сервисах или при удаленном вызове процедур (RPC).
- **Технология**: HTTP/HTTPS, gRPC, Apache Thrift

### 2. Publish-Subscribe (Публикация-Подписка)

- **Описание**: В этом паттерне издатель (publisher) отправляет сообщения без указания конкретного получателя, а подписчики (subscribers) получают сообщения на основе своих подписок.
- **Применение**: Используется для рассылки уведомлений, широковещательной коммуникации и в сценариях, где одно сообщение должно быть доставлено многим получателям.
- **Технология**: Apache Kafka, RabbitMQ, MQTT

### 3. Synchronous (Синхронный)

- **Описание**: Синхронная передача данных требует, чтобы отправитель ожидал ответа после отправки каждого сообщения.
- **Применение**: Подходит для сценариев, где важна тесная связь между отправкой запроса и получением ответа, например, в запросах к базе данных или при обработке транзакций.
- **Технология**: Традиционные веб-сервисы, SQL базы данных

### 4. Asynchronous (Асинхронный)

- **Описание**: В асинхронном обмене сообщениями отправитель не ожидает немедленного ответа и может продолжать свою работу независимо от того, обработано ли сообщение получателем.
- **Применение**: Асинхронные паттерны идеально подходят для фоновой обработки, длительных задач, обмена сообщениями в системах с высокой пропускной способностью и низкой задержкой.
- **Технология**: AMQP, Amazon SQS, Node.js

### 5. Competing Consumers (Соревнующиеся Потребители)

- **Описание**: В этом паттерне несколько потребителей (consumers) прослушивают одну и ту же очередь сообщений, и когда сообщение поступает, один из потребителей выбирается для его обработки.
- **Применение**: Эффективен для масштабирования обработки сообщений, распределяя нагрузку между несколькими экземплярами потребителей.
- **Технология**: RabbitMQ, Apache Kafka
### 6. Work Queues (Очереди Работы)

- **Описание**: Распределение задач между несколькими рабочими процессами, где каждая задача обрабатывается один раз одним рабочим процессом.
- **Применение**: Подходит для распределённой обработки задач, когда задачи могут быть независимо выполнены различными рабочими процессами.
- **Технология**: Celery (с использованием RabbitMQ или Redis)

### 7. Message Routing (Маршрутизация Сообщений)

- **Описание**: Определение правил или критериев для маршрутизации сообщений по различным путям или в разные очереди.
- **Применение**: Используется для управления потоком данных в системе, например, для фильтрации, агрегации или преобразования сообщений.
- **Технология**: Apache Camel, Mule ESB

### 8. Scatter-Gather (Разброс-Сбор)

- **Описание**: Отправка запроса нескольким получателям и последующий сбор и агрегация ответов.
- **Применение**: Подходит для ситуаций, когда необходимо выполнить параллельные запросы и собрать результаты, например, для агрегации данных из нескольких источников.
- **Технология**: Apache Kafka, Apache Spark

### 9. Fan-out/Fan-in (Разветвление/Схождение)

- **Описание**: Распространение сообщения на несколько получателей (fan-out) и последующее схождение результатов обработки (fan-in).
- **Применение**: Эффективен для параллельной обработки и последующей агрегации результатов.
- **Технология**: AWS Lambda, Google Cloud Functions

[Cloud design patterns - Azure Architecture Center | Microsoft Learn](https://learn.microsoft.com/en-us/azure/architecture/patterns/)