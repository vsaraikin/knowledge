# Databases

## General

### Разница SQL и NoSQL баз данных

1. SQL databases use structured query language (SQL) and have a predefined schema. NoSQL databases have dynamic schemas for unstructured data.
2. SQL databases are vertically scalable (more power e.g. CPUs), while NoSQL databases are horizontally scalable (more machines).
3. SQL databases are table-based, while NoSQL databases are document, key-value, graph, or wide-column stores.
4. SQL databases are better for multi-row transactions, while NoSQL is better for unstructured data like documents or JSON.

## Функции в SQL

### Виды JOIN'ов

![Untitled](sql-joins.png)

### Оконные функции

**Оконная функция в SQL** — функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для этого набора строк в отдельном столбце.

![sql-funcs.png](sql-funcs.png)

### UNION

UNION - комбинирует результат 2х и более SELECT запросов

Таблицы для UNION запросы должны иметь одинаковое:

- кол-во колонок
- типы колонок
- порядок колонок

### MERGE

Merge позволяет сделать операцию UPDATE, INSERT, DELETE без предварительного SELECT данных из таблицы. Он используется, когда надо надо данные из одной таблицы перебросить в другую.

### UPSERT

UPSERT позволяет выполнять команду insert если запись уже существует (с такими уникальными значениями),

### EXPLAIN

Это **удобное средство, которое помогает оптимизировать запросы**. С помощью инструкций EXPLAIN можно получать информацию о том, как выполняются инструкции SQL.

### EXPLAIN ANALYSE

As you correctly mention, the difference between explain & explain analyze is that **the former generates the query plan by estimating the cost, while the latter actually executes the query.** Thus, explain analyze will give you more accurate query plan / cost.

## Транзакции

### Что такое транзакция

Транзакция — это элементарная операция в базе данных.

Однако транзакция может состоять и из нескольких операций: в этом ключе — это логически целостная процедура, в которой должны быть выполнены либо все операции — либо ни одна из них.

Транзакция начинается с команды BEGIN и заканчивается командой commit либо отменяется командой rollback

### Какие есть уровни изоляции транзакций?

| Уровень изоляции | «Грязное» чтение        | Неповторяемое чтение | Фантомное чтение        | Аномалия сериализации |
| ---------------- | ----------------------- | -------------------- | ----------------------- | --------------------- |
| Read uncommitted | Допускается, но не в PG | Возможно             | Возможно                | Возможно              |
| Read committed   | Невозможно              | Возможно             | Возможно                | Возможно              |
| Repeatable read  | Невозможно              | Невозможно           | Допускается, но не в PG | Возможно              |
| Serializable     | Невозможно              | Невозможно           | Невозможно              | Невозможно            |

Базовый уровень изоляции в **PostgreSQL – Read Committed.**

Причина наличия в PostgreSQL только трёх уровней изоляции состоит в том, что только так можно сопоставить стандартные уровни изоляции с архитектурой многоверсионного управления конкурентным доступом.

Базовый уровень изоляции в **MySQL – Repeatable read.**

**"Грязное" чтение**: Транзакция читает данные, записанные параллельной незавершённой транзакцией.

**Неповторяемое чтение**: Транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изменены другой транзакцией (которая завершилась после первого чтения).

**Фантомное чтение**: Транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия, и обнаруживает, что набор строк, удовлетворяющих условию, изменился из-за транзакции, завершившейся за это время.

**Аномалия сериализации**: Когда невозможно предсказать в каком порядке выполнятся транзакции. Важно, когда берем проценты от числа.

- 1000 * 110% + 1000 = 2100
- (1000 + 1000) * 110% = 2200

## Как выбрать нужный уровень транзакции?

Для выбора нужного уровня изоляции транзакций используется команда [SET TRANSACTION](https://postgrespro.ru/docs/postgresql/9.4/sql-set-transaction).

### ACID (atomicity, consistency, isolation, durability)

ACID — набор требований к транзакционной системе, обеспечивающий наиболее надёжную и предсказуемую её работу

- ***Атомарность*** гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.

- ***Констистетность***, то есть до выполнения операции и после база остается постоянной.

- ***Изолированность***. Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. 

	- Блокировки — это когда мы блокируем данные в базе.
	- Версии — это когда внутри базы при каждом обновлении создается новая версия данных и сохраняется старая.

- ***Надежность***. Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.

### CAP теорема

Теорема CAP — эвристическое утверждение о том, что в любой реализации распределённых вычислений возможно обеспечить не более двух из трёх следующих свойств

- *согласованность данных* (англ. *consistency*) — во всех вычислительных узлах в один момент времени данные не противоречат друг другу;
- *доступность* (англ. *availability*) — любой запрос к распределённой системе завершается корректным откликом, однако без гарантии, что ответы всех узлов системы совпадают;
- *устойчивость к разделению* (англ. *partition tolerance*) — расщепление распределённой системы на несколько изолированных секций не приводит к некорректности отклика от каждой из секций.

![Untitled](cap.png)

### MySQL vs PostgreSQL?

PostgreSQL быстрая open-source СУБД, а MySQL более прост в настройке.

Улучшенная конкурентность в Postgres засчет MVCC, который поддерживает параллельный доступ.

|  | PostgreSQL | MySQL |
| --- | --- | --- |
| Architecture | Object relational; multiprocess | Relational; single process |
| Data types supported | Numeric, date/time, character, boolean, enumerated, geometric, network address, JSON, XML, HSTORE, arrays, ranges, composite https://www.postgresql.org/docs/current/datatype.html | Numeric, date/time, character, spatial, JSON https://dev.mysql.com/doc/refman/8.0/en/data-types.html |
| Indexes supported | B-tree, hash, GiST, SP-GiST, GIN, and BRIN | Primarily B-tree; R-tree, hash, and inverted indexes for certain data types |
| Performance | Suited for applications with high volume of both reads and writes | Suitable for applications with high volume of reads |
| Security | Access control, multiple encrypted connection options https://www.postgresql.org/docs/13/runtime.html | Access control, encrypted connections https://dev.mysql.com/doc/refman/8.0/en/security.html |

## Запросы

### Как разобраться почему запрос долго работает?

- Анализ запроса. Проверьте, не запрашиваете ли вы слишком много данных, есть ли правильные соединения и джойны между таблицами.
- Используйте EXPLAIN, которая показывает план выполнения запроса, какие индексы используются, какие шаги занимают больше всего времени и т. д.
- Индексы. Убедитесь, что у вас есть необходимые индексы для столбцов, которые часто используются в условиях WHERE, JOIN и ORDER BY. Не стали ли индексы фрагментированными или неоптимальными со временем?
- Оптимизация запросов
- Мониторинг ресурсов (например, ЦПУ, память, диск).
- Метрики производительности базы данных, такие как время отклика, очередь запросов и т. д.
- Проверить логи базы данных на наличие ошибок или предупреждений, связанных с вашим запросом или другими аспектами работы СУБД.
- Сетевые задержки

### Как оптимизировать запрос?

**1. Оптимизация кода**

Вместо звездочки использовать имена столбцов

Дополнительный Where

**2. Сведите к минимуму использование подзапросов.**

Используйте оператор `IN` аккуратно, поскольку на практике он имеет низкую производительность и может быть эффективен только при использовании критериев фильтрации в подзапросе.

**3. Использовать WITH & CTE.**

Common Table Expressions — временные таблицы, которые создаются только в рамках выполнения какой-либо операции и удаляются, как только становятся не нужны

## Индексы

### Что такое индекс?

Индекс – это объект базы данных, создаваемый с целью повышения производительности поиска данных.

Не стоит использовать индексы для небольших таблиц. Не стоит использовать индексы для таблиц, в которых, как предполагается, будут часто добавляться новые данные, либо эти данные будут изменяться.

Индекс нужен тогда, когда запросы выполняются часто и долго. Ненужные индексы нужно удалять.

### Виды и типы индексов

- **Кластерные индексы -** хранят данные записей целиком и отдельно.
- **Обычные индексы -** хранят ссылки на записи (PK). Используются отсортированные таблицы, поэтому потребление памяти там меньше.

**В БД основные типы:**
- B-tree 
- пространственные индексы (spatial grid)
- hash index
- bitmap
- function based
- reverted

В PostgreSQL могут быть и другие виды – GiST, GIN.

|                      | MySQL                            | PostgreSQL                                  | MS SQL                                                                                       | Oracle                                     |
| -------------------- | -------------------------------- | ------------------------------------------- | -------------------------------------------------------------------------------------------- | ------------------------------------------ |
| B-Tree index         | Есть                             | Есть                                        | Есть                                                                                         | Есть                                       |
| Spatial indexes      | R-Tree с квадратичным разбиением | Rtree_GiST(используется линейное разбиение) | 4-х уровневый Grid-based spatial index (отдельные для географических и геодезических данных) | R-Tree c квадратичным разбиением; Quadtree |
| Hash index           | Только в таблицах типа Memory    | Есть                                        | Нет                                                                                          | Нет                                        |
| Bitmap index         | Нет                              | Есть                                        | Нет                                                                                          | Есть                                       |
| Reverse index        | Нет                              | Нет                                         | Нет                                                                                          | Есть                                       |
| Inverted index       | Есть                             | Есть                                        | Есть                                                                                         | Есть                                       |
| Partial index        | Нет                              | Есть                                        | Есть                                                                                         | Нет                                        |
| Function based index | Нет                              | Есть                                        | Есть                                                                                         | Есть                                       |

### Index vs PK

A key (minimal superkey) is a set of attributes, the values of which are unique for every tuple (every row in the table at some point in time).

An index is a performance optimisation feature that enables data to be accessed faster.

### PK vs FK

PK — однозначно идентифицирует какую-то строку в таблице.
FK — для связи таблиц с друг другом

Оба могут состоять более чем из одного столбца.

### Какие есть типы связей?

Есть три типа связей: 

- 1 к 1: данные о сотрудниках дочерних отделов (почти всегда такие таблицы объединяются)
- 1 ко многим: у одного клиента может быть несколько телефонов, но в тоже время мы можем быть уверены в том, что один конкретный номер может быть только у одного клиента
- много ко многим: первое — одну книгу может написать несколько авторов, второе — автор может написать несколько книг.

### Как чистить индексы?

- `DROP INDEX ... on ...`
- `VACUUM`
## Другое

### Масштабирование БД

**Горизонтальное масштабирование:** увелечение кол-ва серверов

**Вертиклаьное масштабирование:** наращивание мощностей сервера

**Репликация:** копирование данных между серверами. При использовании такого метода выделяют два типа серверов: master и slave. Мастер используется для записи или изменения информации, слейвы — для копирования информации с мастера и её чтения.

![Untitled](db-1.png)

**Партицирование:** в разбиении данных на части по какому-либо признаку. Например, таблицу можно разбить на две по признаку чётности. поиск осуществляется не по всей таблице, а лишь по её части.

![Untitled](db-2.png)

**Шардинг:** части таблицы хранятся раздельно, на разных физических серверах.

![Untitled](db-3.png)

### Нормализация БД

**Нормализация** — это процесс организации данных в базе данных, включающий создание таблиц и установление отношений между ними в соответствии с правилами, которые обеспечивают защиту данных и делают базу данных более гибкой, устраняя избыточность и несогласованные зависимости.

Избыточность устраняется, как правило, за счёт декомпозиции отношений (таблиц), т.е. разбиения одной таблицы на несколько.

Избыточность данных – это когда одни и те же данные хранятся в базе в нескольких местах, именно это и приводит к аномалиям.

**Нормальные формы БД:**

| Форма                                      | Концепт                                                                                                 |
|--------------------------------------------|----------------------------------------------------------------------------------------------------------|
| 1NF                                        | - нет дублирующихся строк в таблице <br> - все атрибуты простые (атомарные)                               |
| 2NF = 0 + 1NF                              | - у таблицы должен быть первичный ключ PK <br> - все атрибуты должны описывать первичный ключ полностью, а не только какую-то его часть |
| 3NF = 0 + 2NF                              | Не должно быть зависимостей одних неключевых атрибутов от других                                         |
| BOYCE-CODD NORMAL FORM (BCNF OR 3.5NF) = 0 + 3NF | Несколько полей имеют нетривиальную и неприводимую слева функциональную зависимость, которую можно вынести в отдельную таблицу |
| 4NF = 0 + BCNF                             | {Ресторан, Вид пиццы, Район доставки} -> декомпозиция в: <br> {Ресторан} → {Вид пиццы} <br> {Ресторан} → {Район доставки} |


### Как можно оптимизировать запрос с частичным поиском по строке?

- `LIKE`
- Используйте индексы:
	- Для запросов, начинающихся с определенной подстроки (например, `LIKE 'substring%'`), обычный индекс может быть эффективным.
	- Для запросов с подстрокой в середине или в конце строки, рассмотрите возможность использования полнотекстового индекса (Full-Text Index). Во многих СУБД, таких как MySQL и PostgreSQL, есть поддержка полнотекстового поиска.

### Что такое SQL Injection?

Это атака на базу данных, которая позволит выполнить некоторое действие, которое не планировалось создателем скрипта.

### Триггеры БД

Триггеры представляют обработчики событий. Они выполняются при наступлении какого-либо простого действия в SQL. Такими действиями обычно являются: удаление, вставка и обновление данных.

### Курсоры

Курсоры – некое подмножество из таблицы, результирующий набор данных, в которым можно выполнять операции с отдельными строками.

### Хранимые процедуры и функции

Хранимые процедуры позволяют содержать часто используемый SQL запрос на сервере. Это обеспечивает лучшую производительность, поскольку данный запрос должен анализироваться только однажды и уменьшается трафик между сервером и клиентом.

Хранимые функции - тоже что и процедуры, но при этом возвращают обязательно какое-то значение.

| Плюсы | Минусы |
| --- | --- |
| Скорость | PL/PGSQL старый и древний язык |
| Управление доступом | Нету менеджера зависимостей. |
| Меньшая вер-ть SQL Injection |  |

### ETL

**Extract, Transform, Load ***—* общий термин для всех процессов миграции данных из одного источника в другой.

**Типичные этапы ETL-процесса:**

- извлечение данных из источника (файл, БД, веб-страница и пр);
- очистка данных (приведение разнородных данных к единому формату, удаление лишнего, устранение недочетов и пр);
- обогащение (применение алгоритмов или внешних источников для получения новых данных, связанных с обрабатываемыми данными);
- трансформирование;
- загрузка (интеграция в единую целевую модель).

### Что такое VACUUM в PostgreSQL?

VACUUM высвобождает пространство, занимаемое «мёртвыми» кортежами. При обычных операциях PostgreSQL кортежи, удалённые или устаревшие в результате обновления, физически не удаляются из таблицы; они сохраняются в ней, пока не будет выполнена команда VACUUM .

## Произошел сбой, как локализовать проблему?

1. Логи
2. Трассировки
3. Метрики

Трассировка (tracing) и отладка (debugging) — это два различных метода исследования и устранения проблем в программном обеспечении, но они имеют разные цели и используются в разных контекстах.

### Трассировка (Tracing):

Определение: Трассировка — это процесс записи последовательности операций или событий в программе. Это часто делается с помощью вставки специальных инструкций в код, которые записывают информацию в лог или другое хранилище.
  
Цель: Помогает понять, как программа работает "в реальном времени", идентифицировать узкие места, проблемы производительности или непредвиденные пути выполнения.

Применение: Часто используется в продакшен-системах для мониторинга поведения программы, анализа производительности и выявления аномалий.

Инструменты: Существуют специализированные инструменты для трассировки, такие как Jaeger, Zipkin, OpenTracing и другие.

### Отладка (Debugging):

Определение: Отладка — это процесс идентификации, изучения и устранения ошибок или проблем в программном коде.

Цель: Найти и исправить ошибки в программе, чтобы она работала корректно.

Применение: Обычно используется в процессе разработки программного обеспечения, когда разработчик сталкивается с неожиданным поведением или ошибками.

Инструменты: Отладчики (debuggers), такие как GDB, LLDB, pdb (для Python) и многие другие, позволяют разработчикам останавливать выполнение программы, просматривать и изменять значения переменных, анализировать стек вызовов и так далее.

### Метрики

**Производительность и ресурсы:**

- Загрузка ЦПУ
- Использование памяти
- Использование диска
- Пропускная способность сети
- Метрики приложения:


**Метрики ошибок:**

- Количество исключений или ошибок
- Количество необработанных ошибок
- Количество ошибок по различным категориям или типам

**Метрики базы данных:**  

- Запросы в секунду
- Время отклика запроса
- Размер базы данных
- Количество одновременных соединений

**Метрики инфраструктуры:**  

- Состояние и доступность сервисов
- Время простоя
- Процент использования ресурсов

## Планирование запросов

Когда вы отправляете запрос к базе данных, СУБД не просто начинает его исполнять. Сначала она пытается определить наиболее эффективный способ выполнения этого запроса. Этот процесс называется планированием запросов.

- Парсинг запроса: Сначала запрос анализируется, чтобы убедиться, что он синтаксически верен.
- Оценка возможных планов: СУБД рассматривает различные способы выполнения запроса. Например, какие индексы использовать, в каком порядке соединять таблицы и т. д.
- Выбор наилучшего плана: На основе различных метрик (например, стоимости дискового ввода-вывода, ожидаемого количества обрабатываемых строк) СУБД выбирает наиболее оптимальный план выполнения запроса.
- Исполнение плана: После выбора плана СУБД начинает исполнение запроса в соответствии с этим планом.

## Селективность:

Селективность — это мера того, как много данных будет выбрано из таблицы или индекса в результате выполнения определенного условия в запросе. Селективность может быть выражена как процент или доля от общего числа записей.

- Высокая селективность: Запрос выбирает маленький процент данных из таблицы. Такие запросы обычно эффективнее, так как они обрабатывают меньше данных.
- Низкая селективность: Запрос выбирает большой процент данных из таблицы.

Селективность важна для СУБД при планировании запросов, потому что:

1. Оптимизация использования индексов: Если условие в запросе имеет высокую селективность, то использование индекса может быть очень эффективным. Если селективность низкая, иногда быстрее просканировать всю таблицу, чем использовать индекс.

2. Определение порядка соединения таблиц: Если у вас есть запрос, который соединяет несколько таблиц, селективность условий может влиять на порядок, в котором эти таблицы будут соединены.


[Топ-65 вопросов по SQL с собеседований, к которым вы должны подготовиться в 2019 году. Часть I](https://habr.com/ru/company/otus/blog/461067/)

