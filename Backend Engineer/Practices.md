# Practices

- [Practices](#practices)
  * [KISS](#kiss)
  * [DRY](#dry)
  * [YAGNI](#yagni)
  * [SLAP](#slap)
  * [SOLID принципы](#solid-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B)
- [Что такое code cohesion & code coupling](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-code-cohesion--code-coupling)
## Practices

### KISS

*Keep It Stupid Simple* («Придерживайся простоты») велит вам следить за тем, чтобы код оставался как можно более простым. Чем код проще, тем легче в нем разобраться, как вам, так и другим людям, занимающимся его поддержкой. 

### DRY

Принцип *Don’t Repeat Yourself* («Не повторяйся») напоминает нам, что каждое повторяемое поведение в коде следует обособлять (например, выделять в отдельную функцию) для возможности многократного использования. 

### YAGNI

Принцип *You Aren’t Gonna Need It* («Тебе это не понадобится») говорит о том, что нежелательно оставлять в продакшене «точки расширения» (места, предназначенные только для того, чтобы позволить вам в будущем легко добавить новый функционал). 

### SLAP

Принцип *Single Level of Abstraction Principle* («Принцип единого уровня абстракций») означает, что функции должны иметь единый уровень абстракции. Скажем, функция, читающая input, не должна также обрабатывать полученные данные. Для этого она должна задействовать отдельную функцию, находящуюся на другом, более низком уровне абстракции. Чем более общей является функция и чем больше других функций она использует, тем выше она располагается в абстракционной иерархии.

### SOLID принципы

*SOLID* - это аббревиатура от 5 принципов, описанных Робертом Мартином, которые способствуют созданию хорошего объектно-ориентированного (и не только) кода.

**S**: Single Responsibility Principle (Принцип единственной ответственности).

> Каждый класс должен решать лишь одну задачу.


**O**: Open-Closed Principle (Принцип открытости-закрытости).

> Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

**L**: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).

> Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.

**I**: Interface Segregation Principle (Принцип разделения интерфейса).

> Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.

**D**: Dependency Inversion Principle (Принцип инверсии зависимостей).

> Объектом зависимости должна быть абстракция, а не что-то конкретное.

- Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

## Что такое code cohesion & code coupling

**Связанность модулей (coupling)**, часто называемую **зацеплением**, характеризует степень независимости модулей. При проектировании систем необходимо стремиться, чтобы модули имели минимальную зависимость друг от друга, т.е. были минимально «сцеплены» между собой (отсюда и термин «сцепление» или связанность). Это требование вытекает из одного из основных принципов системного подхода, требующего минимизации информационных потоков между подсистемами.

**Связность (cohesion)** характеризует целостность, «плотность» модуля, т.е. насколько модуль является простым с точки зрения его использования. В идеале модуль должен выполнять одну единственную функцию и иметь минимальное число «ручек управления». Примером модуля имеющего максимальную связность является модуль проверки орфографии, вычисления заработной платы сотрудника, вычисления логарифма функции. Если связанность является характеристикой системы, то связность характеризует отдельно взятый модуль.